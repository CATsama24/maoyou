<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>å“¥ä»¬çš„æˆ˜æ–—</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <style>
    /* å“åº”å¼å¸ƒå±€ä¸åŸºç¡€æ ·å¼ */
    html {
      font-size: 14px;
      font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background: #181818;
      color: #fff;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-height: 100vh;
      width: 100vw;
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      width: 100vw;
      overflow-x: hidden;
      background: #181818;
    }
    .container {
      display: flex;
      flex-direction: column;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }
    button, input, select {
      font-size: 1rem;
      border-radius: 10px;
      padding: 0.7em 1.5em;
      min-width: 44px;
      min-height: 44px;
      box-sizing: border-box;
      border: none;
      outline: none;
      background: #b266ff;
      color: #fff;
      margin: 0.5em auto;
      display: block;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s, transform 0.15s;
    }
    button:active {
      background: #6cf;
      color: #222;
      transform: scale(0.97);
    }
    button:hover {
      background: #a266ff;
      box-shadow: 0 2px 12px #6cf3;
    }
    #info, #upgrade-panel, #history-panel {
      max-width: 480px;
      margin: 0 auto;
      padding: 0 8px;
    }
    #info { text-align: center; font-size: 1.2rem; }
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100vw;
      max-width: 480px;
      margin: 0 auto;
      box-sizing: border-box;
    }
    #game {
      display: block;
      margin: 0 auto;
      background: #222;
      border-radius: 12px;
      width: 100vw;
      max-width: 750px;
      aspect-ratio: 750/1624;
      min-width: 180px;
      min-height: 320px;
      height: min(90vh, calc(100vw * 1624 / 750));
      max-height: 90vh;
      touch-action: none;
    }
    /* å¼¹çª—ã€é¢æ¿ç­‰ */
    .modal, .panel {
      width: 90vw;
      max-width: 420px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.1em;
    }
    #upgrade-panel {
      position: fixed;
      left: 0; right: 0; top: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #upgrade-box {
      background: #222;
      border: 2px solid #6cf;
      border-radius: 12px;
      padding: 32px 24px;
      min-width: 220px;
      text-align: center;
      box-shadow: 0 0 24px #000;
    }
    #upgrade-box h2 {
      color: #6cf;
      margin-bottom: 18px;
      font-size: 1.5rem;
    }
    .upgrade-btn {
      display: block;
      width: 90%;
      margin: 16px auto;
      padding: 18px;
      font-size: 1.3rem;
      background: #444;
      color: #fff;
      border: 1px solid #6cf;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .upgrade-btn:active {
      background: #6cf;
      color: #222;
    }
    /* æ‰‹æœºç«¯ä¸“å±ä¼˜åŒ– */
    @media (max-width: 575.98px) {
      html { font-size: 14px; }
      .container { padding: 8px; }
      button, .nav-item {
        min-height: 48px;
        padding: 12px 16px;
      }
      body { overflow-x: hidden; }
      #game-container { max-width: 100vw; }
      #game { min-height: 180px; }
    }
    /* å¹³æ¿é€‚é… */
    @media (min-width: 576px) and (max-width: 1023.98px) {
      html { font-size: 15px; }
      .container { padding: 20px; }
      #game-container { max-width: 700px; }
      #game { min-height: 240px; }
    }
    /* PCç«¯ä¸“å±æ ·å¼ */
    @media (min-width: 1024px) {
      html { font-size: 16px; }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        flex-direction: row;
        gap: 32px;
      }
      #game-container { max-width: 700px; }
      #game { min-height: 320px; }
      .sidebar { display: block; }
    }
  </style>
</head>
<body style="margin:0;padding:0;overflow:hidden;height:100vh;width:100vw;">
  <div id="main-wrapper" style="position:fixed;left:0;top:0;width:100vw;height:100vh;overflow:hidden;display:flex;flex-direction:column;">
    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen" style="position:fixed;left:0;top:0;width:100vw;height:100vh;background:radial-gradient(ellipse at 60% 40%, #23234a 0%, #181818 80%);z-index:100;display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;animation:fadeIn 1.2s;">
      <div style="position:absolute;left:0;top:0;width:100vw;height:100vh;pointer-events:none;z-index:0;">
        <div style="position:absolute;left:10vw;top:20vh;width:120px;height:120px;background:radial-gradient(circle,#6cf8,transparent 70%);filter:blur(18px);opacity:0.5;"></div>
        <div style="position:absolute;right:8vw;bottom:18vh;width:160px;height:160px;background:radial-gradient(circle,#ffe06688,transparent 70%);filter:blur(24px);opacity:0.4;"></div>
        <div style="position:absolute;left:50vw;top:60vh;width:90px;height:90px;background:radial-gradient(circle,#ff6a0088,transparent 70%);filter:blur(16px);opacity:0.3;"></div>
      </div>
      <div style="font-size:2.8rem;font-weight:bold;background:linear-gradient(90deg,#6cf,#ffe066,#ff6a00,#00e0ff,#fff700,#6cf);background-size:200% 200%;background-clip:text;-webkit-background-clip:text;color:transparent;-webkit-text-fill-color:transparent;text-shadow:0 4px 32px #000a,0 1px 0 #fff3;letter-spacing:2px;margin-bottom:18px;animation:shineTitle 2.5s linear infinite alternate,fadeInUp 1s;z-index:1;">å“¥ä»¬çš„æˆ˜æ–—</div>
      <div style="font-size:1.3rem;color:#fff;opacity:0.85;margin-bottom:38px;animation:fadeInUp 1.5s 0.3s both;z-index:1;">æ•¬è¯·æœŸå¾…å„ç§å“¥</div>
      <button id="start-btn" style="padding:18px 48px;font-size:24px;background:linear-gradient(90deg,#6cf,#ffe066,#6cf);background-size:200% 200%;color:#222;border:none;border-radius:32px;cursor:pointer;box-shadow:0 4px 24px #6cf6,0 1.5px 0 #fff3;transition:transform 0.12s,box-shadow 0.2s;background-position:0% 50%;z-index:1;animation:fadeInUp 1.2s 0.5s both;">å¼€å§‹æ¸¸æˆ</button>
      <style>
        @keyframes shineTitle {
          0% {background-position:0% 50%;}
          100% {background-position:100% 50%;}
        }
        @keyframes fadeInUp {
          0% {opacity:0;transform:translateY(40px);}
          100% {opacity:1;transform:translateY(0);}
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1;}
        }
        #start-btn:hover {
          box-shadow:0 6px 32px #ffe066cc,0 1.5px 0 #fff3;
          background-position:100% 50%;
          transform:scale(1.06);
        }
        #start-btn:active {
          transform:scale(0.97);
        }
      </style>
    </div>
    <div id="top-ui">
      <div id="info" style="margin-top:8px;"></div>
      <!-- é¡¶éƒ¨æŒ‰é’®å·²å»é™¤ï¼Œåªä¿ç•™ä¿¡æ¯æ  -->
    </div>
    <div id="game-container" style="flex:1 1 0;display:flex;align-items:center;justify-content:center;min-height:0;width:100vw;height:100vh;max-width:100vw;max-height:100vh;position:relative;background:none;">
      <canvas id="game" style="display:block;"></canvas>
    </div>
    <div id="upgrade-panel">
      <div id="upgrade-box">
        <h2>è¯·é€‰æ‹©å‡çº§</h2>
        <div id="upgrade-options"></div>
      </div>
    </div>
    <div id="history-panel" style="display:none;position:fixed;left:0;right:0;top:0;bottom:0;background:rgba(0,0,0,0.7);z-index:20;align-items:center;justify-content:center;">
      <div style="background:#222;border:2px solid #6cf;border-radius:12px;padding:32px 24px;min-width:220px;max-width:90vw;max-height:80vh;overflow:auto;text-align:left;box-shadow:0 0 24px #000;">
        <h2 style="color:#6cf;margin-bottom:18px;font-size:22px;">å‡çº§å†å²</h2>
        <div id="history-list"></div>
        <button id="close-history" style="margin-top:18px;padding:8px 24px;font-size:18px;background:#444;color:#fff;border:1px solid #6cf;border-radius:10px;cursor:pointer;">å…³é—­</button>
      </div>
    </div>
    <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
    <div id="gameover-panel" style="display:none;position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.55);backdrop-filter:blur(6px);z-index:200;align-items:center;justify-content:center;animation:fadeIn 0.7s;">
      <div id="gameover-box" style="background:rgba(34,34,44,0.98);border:2.5px solid #6cf;border-radius:22px;padding:48px 32px 36px 32px;min-width:220px;max-width:90vw;max-height:80vh;overflow:auto;text-align:center;box-shadow:0 0 32px #000a,0 2px 0 #fff3;animation:fadeInUp 0.7s;">
        <div id="gameover-title" style="font-size:2.2rem;margin-bottom:28px;font-weight:bold;text-shadow:0 2px 16px #000a,0 1px 0 #fff3;"></div>
        <div id="gameover-btns">
          <button id="go-back-btn">è¿”å›</button>
          <button id="retry-btn">é‡è¯•</button>
        </div>
      </div>
      <style>
        #gameover-title.win {
          background:linear-gradient(90deg,#ffe066,#fff700,#fff3b0,#ffe066);
          background-size:200% 200%;
          background-clip:text;-webkit-background-clip:text;color:transparent;-webkit-text-fill-color:transparent;
          animation:shineTitle 2.5s linear infinite alternate;
          text-shadow:0 2px 24px #ffe06655,0 1px 0 #fff3;
        }
        #gameover-title.fail {
          color:#ff3b3b;
          text-shadow:0 2px 24px #ff3b3b88,0 1px 0 #fff3;
        }
        #gameover-btns {
          display: flex;
          justify-content: center;
          align-items: center;
          gap: 16px;
          flex-wrap: wrap;
          margin-top: 18px;
        }
        #gameover-btns button {
          padding:14px 44px;font-size:20px;margin:12px 12px 0 12px;
          border:none;border-radius:32px;cursor:pointer;box-shadow:0 2px 16px #6cf6,0 1.5px 0 #fff3;
          background:linear-gradient(90deg,#6cf,#ffe066,#6cf);background-size:200% 200%;color:#222;transition:transform 0.12s,box-shadow 0.2s;background-position:0% 50%;
        }
        #gameover-btns button:hover {
          box-shadow:0 6px 32px #ffe066cc,0 1.5px 0 #fff3;
          background-position:100% 50%;
          transform:scale(1.06);
        }
        #gameover-btns button:active {
          transform:scale(0.97);
        }
        #gameover-btns button:last-child {
          background:linear-gradient(90deg,#444,#6cf,#444);color:#fff;
        }
      </style>
    </div>
    <script>
      // Safari å…¼å®¹ roundRect polyfill
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
          r = r || 0;
          this.beginPath();
          this.moveTo(x + r, y);
          this.lineTo(x + w - r, y);
          this.quadraticCurveTo(x + w, y, x + w, y + r);
          this.lineTo(x + w, y + h - r);
          this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
          this.lineTo(x + r, y + h);
          this.quadraticCurveTo(x, y + h, x, y + h - r);
          this.lineTo(x, y + r);
          this.quadraticCurveTo(x, y, x + r, y);
          this.closePath();
        }
      }
      // Safari å…¼å®¹ requestAnimationFrame
      window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
      // 1. å…ˆå£°æ˜å…¨å±€å˜é‡
      let STAGE_WIDTH = 750;
      let STAGE_HEIGHT = 1624;
      // HERO_Yæ•´ä½“ä¸Šç§»ï¼Œç»éªŒæ¡ä¸Šæ–¹ç•™å‡ºç©ºé—´
      let HERO_Y_OFFSET = 110; // è‹±é›„åº•éƒ¨è·ç¦»ç”»å¸ƒåº•éƒ¨110px
      let HERO_Y = STAGE_HEIGHT - HERO_Y_OFFSET;
      let STAGE_PLAY_HEIGHT = STAGE_HEIGHT;
      let STAGE_TOP_OFFSET = 0;

      // 2. å†å®šä¹‰å‡½æ•°
      function fixCanvasDpi(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const topUIH = document.getElementById('top-ui')?.offsetHeight || 0;
        const bottomSafe = 20;
        const availW = window.innerWidth;
        let availH = window.innerHeight - topUIH - bottomSafe;
        if (window.visualViewport && window.visualViewport.height) {
          availH = window.visualViewport.height - topUIH - bottomSafe;
        }
        const scale = Math.min(availW / 750, availH / 1624);
        const cssWidth = Math.round(750 * scale);
        const cssHeight = Math.round(1624 * scale);
        // ç‰©ç†åƒç´ å°ºå¯¸
        const realWidth = Math.round(cssWidth * dpr);
        const realHeight = Math.round(cssHeight * dpr);
        canvas.style.width = cssWidth + 'px';
        canvas.style.height = cssHeight + 'px';
        canvas.width = realWidth;
        canvas.height = realHeight;
        // ä¿è¯ç”»å¸ƒå†…å®¹ç¼©æ”¾åˆ°é€»è¾‘åæ ‡
        const ctx = canvas.getContext('2d');
        ctx.setTransform(realWidth/750, 0, 0, realHeight/1624, 0, 0);
        STAGE_WIDTH = 750;
        STAGE_HEIGHT = 1624;
        HERO_Y = STAGE_HEIGHT - HERO_Y_OFFSET;
        STAGE_PLAY_HEIGHT = STAGE_HEIGHT;
        STAGE_TOP_OFFSET = 0;
      }

      // 3. å†è·å–DOMå’Œè°ƒç”¨
      const canvas = document.getElementById('game');
      fixCanvasDpi(canvas);
      window.addEventListener('resize', () => fixCanvasDpi(canvas));
      const ctx = canvas.getContext('2d');
      const info = document.getElementById('info');
      // ================== åŸºç¡€è®¾ç½® ==================
      const HERO_MAX = 5;
      const HERO_MARGIN = 100;

      // è‹±é›„é…ç½®
      const HERO_CONFIGS = [
        {
          name: "å°„æ‰‹å“¥",
          type: "archer",
          range: 0.75,
          skill: "arrow",
          color: "#6cf"
        },
        {
          name: "æ¿€å…‰å“¥",
          type: "laser",
          range: 1,
          skill: "laser",
          color: "#ffe066"
        },
        {
          name: "ç«ç„°å“¥",
          type: "fire",
          range: 0.5,
          skill: "fireball",
          color: "#ff6a00"
        },
        {
          name: "å¯’å†°å“¥",
          type: "ice",
          range: 2/3,
          skill: "ice",
          color: "#00e0ff"
        },
        {
          name: "æ‰“é›·å“¥",
          type: "lightning",
          range: 0.5,
          skill: "lightning",
          color: "#fff700"
        }
      ];

      // åœ¨HERO_CONFIGSå‰æ·»åŠ HERO_ICONSå®šä¹‰
      const HERO_ICONS = {
        archer: 'ğŸ¹',
        fire: 'ï¿½ï¿½',
        laser: 'ğŸ”¦',
        ice: 'â„ï¸',
        lightning: 'âš¡'
      };

      // ================== å·¥å…·å‡½æ•° ==================
      function shuffle(arr) {
        return arr.map(v => [Math.random(), v])
                  .sort((a, b) => a[0] - b[0])
                  .map(v => v[1]);
      }
      function getHeroPositions(count) {
        const totalWidth = (count - 1) * HERO_MARGIN;
        const startX = STAGE_WIDTH / 2 - totalWidth / 2;
        return Array.from({length: count}, (_, i) => startX + i * HERO_MARGIN);
      }
      function distance(a, b) {
        const dx = a.x - b.x, dy = a.y - b.y;
        return Math.sqrt(dx*dx + dy*dy);
      }

      // ================== ä¼¤å®³æ•°å­— ==================
      let damageNumbers = [];
      function addDamageNumber(x, y, value, heroType, extra) {
        damageNumbers.push({x, y, value, heroType, alpha: 1, vy: -1, time: 0, extra: extra||''});
      }
      function drawDamageNumbers(ctx) {
        damageNumbers.forEach(dmg => {
          ctx.save();
          // é¢œè‰²æ˜ å°„
          let color = '#fff';
          let stroke = '#222';
          switch(dmg.heroType) {
            case 'archer': color = '#fff'; stroke = '#222'; break;
            case 'ice': color = '#00e0ff'; stroke = '#005577'; break;
            case 'fire': color = '#ff3b3b'; stroke = '#a80000'; break;
            case 'lightning': color = '#ffe066'; stroke = '#bba800'; break;
            case 'laser': color = '#b266ff'; stroke = '#4b0066'; break;
          }
          ctx.globalAlpha = dmg.alpha;
          if (dmg.small) {
            ctx.font = '14px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.fillText(dmg.small, dmg.x, dmg.y+18);
          } else {
            ctx.font = 'bold 22px Arial';
            ctx.lineWidth = 3;
            ctx.strokeStyle = stroke;
            ctx.strokeText(dmg.value + (dmg.extra||''), dmg.x, dmg.y);
            ctx.fillStyle = color;
            ctx.fillText(dmg.value + (dmg.extra||''), dmg.x, dmg.y);
          }
          ctx.restore();
          dmg.y += dmg.vy;
          dmg.alpha -= 0.02;
          dmg.time += 1;
        });
        damageNumbers = damageNumbers.filter(dmg => dmg.alpha > 0);
      }

      // ================== è‹±é›„ç±» ==================
      class Hero {
        constructor(config, x) {
          this.config = config;
          this.name = config.name;
          this.type = config.type;
          this.position = { x: x, y: HERO_Y };
          this.level = 1;
          this.cooldown = 0;
          this.lastAttack = 0;
          this.skillState = null;
          this.attackRange = {
            width: STAGE_WIDTH,
            height: STAGE_HEIGHT * config.range
          };
          // æ”»å‡»èŒƒå›´åº•éƒ¨ä¸è‹±é›„å¯¹é½
          if (this.type === 'lightning' || this.type === 'fire') {
            this.attackRange.height *= 1.2;
          }
          this.rangeBottom = () => this.position.y;
          this.rangeTop = () => this.position.y - this.attackRange.height;
          this.rangeLeft = () => (STAGE_WIDTH - this.attackRange.width) / 2;
          this.rangeRight = () => (STAGE_WIDTH + this.attackRange.width) / 2;
          this.rangeCenter = { x: STAGE_WIDTH/2, y: STAGE_HEIGHT/2 };
          // æŠ€èƒ½å±æ€§
          this.combo = 0;
          this.bulletCount = 1;
          this.bulletSplit = 0;
          // ä¼¤å®³å€¼
          this.damage = this.type === 'archer' ? 3 : (this.type === 'fire' ? 6 : (this.type === 'lightning' ? 5 : 0.5));
          // æ¿€å…‰å“¥tickå’ŒæŒç»­
          this.laserWidth = 16;
          this.laserDuration = 2000; // æ¿€å…‰å“¥æŒç»­2ç§’
          this.laserAlphaTick = 1;
          this.laserCombo = 0;
          this.laserDamage = this.type === 'laser' ? 1 : 0.3; // æ¿€å…‰å“¥æ¯0.2ç§’1ç‚¹
          this.laserDurationBonus = 0;
          this.laserWidthBonus = 0;
          this.fireExplosionRadius = 8 * 6;
          this.fireExplosionBonus = 0;
          this.fireCombo = 0;
          this.fireDamageBonus = 0;
          this.iceCombo = 0;
          this.iceDamageBonus = 0;
          this.iceFreeze = 0;
          this.lightningCombo = 0;
          this.lightningDamageBonus = 0;
          this.lightningStun = 0;
        }
        attack(enemies, bullets, effects) {
          const now = Date.now();
          if (now - this.lastAttack < this.getCooldown() / speedMultiplier) return;
          let target = this.findTarget(enemies);
          if (!target) return;
          // é¢„åˆ¤ï¼šè®¡ç®—æå‰é‡
          let bulletSpeed = 16*2/3;
          if (this.type === 'fire') bulletSpeed = 13;
          if (this.type === 'ice') bulletSpeed = 13;
          if (this.type === 'archer') bulletSpeed = 16*2/3*1.3;
          // åªå¯¹æ™®é€šå­å¼¹åšé¢„åˆ¤
          let vx = 0, vy = 0;
          if (target.isBoss || target.type === 'tank') {
            vy = target.speed * speedMultiplier;
          } else if (target.type === 'fast') {
            vy = target.speed * speedMultiplier;
          } else {
            vy = target.speed * speedMultiplier;
          }
          // è®¡ç®—å­å¼¹é£è¡Œæ—¶é—´
          const dx = target.position.x - this.position.x;
          const dy = target.position.y - this.position.y;
          const a = vx*vx + vy*vy - bulletSpeed*bulletSpeed;
          const b = 2 * (dx*vx + dy*vy);
          const c = dx*dx + dy*dy;
          let t = 0;
          if (Math.abs(a) < 1e-6) {
            t = c / Math.max(1e-6, b);
          } else {
            const delta = b*b - 4*a*c;
            if (delta >= 0) {
              const t1 = (-b + Math.sqrt(delta)) / (2*a);
              const t2 = (-b - Math.sqrt(delta)) / (2*a);
              t = Math.max(t1, t2, 0);
            } else {
              t = 0;
            }
          }
          // é¢„æµ‹ç›®æ ‡ç‚¹
          const targetCenter = {
            x: target.position.x + vx * t,
            y: target.position.y + vy * t
          };
          switch(this.type) {
            case 'archer': {
              const baseAngle = Math.atan2(targetCenter.y - this.position.y, targetCenter.x - this.position.x);
              const angleStep = 0.14;
              const n = this.bulletCount;
              if (n % 2 === 1) {
                const center = (n - 1) / 2;
                for (let i = 0; i < n; i++) {
                  const angle = baseAngle + (i - center) * angleStep;
                  bullets.push(new Bullet(this.position, angle, 16*2/3, this.damage, this.config.skill, 1, this.type, this.bulletSplit, 0, 0, null));
                }
              } else {
                const leftCenter = n/2 - 1;
                for (let i = 0; i < n; i++) {
                  const angle = baseAngle + (i - leftCenter) * angleStep;
                  bullets.push(new Bullet(this.position, angle, 16*2/3, this.damage, this.config.skill, 1, this.type, this.bulletSplit, 0, 0, null));
                }
              }
              break;
            }
            case 'fire':
              this.fireballAttack([targetCenter], bullets, effects, 0);
              break;
            case 'ice':
              this.iceAttack([targetCenter], bullets, effects, 0);
              break;
            case 'laser':
              this.laserAttack([targetCenter], effects, 0);
              break;
            case 'lightning':
              this.lightningAttack([targetCenter], effects, 0);
              break;
          }
          this.lastAttack = Date.now();
        }
        getCooldown() {
          switch(this.config.skill) {
            case "arrow": return 1500; // ä¸›æ—å°„æ‰‹1.5ç§’
            case "laser": return 6000; // æ¿€å…‰å“¥6ç§’
            case "fireball": return 3000; // ç«ç„°æ³•å¸ˆ3ç§’
            case "ice": return 2000;
            case "lightning": return 2500; // é—ªç”µå“¥2.5ç§’
          }
          return 1000;
        }
        getCombo() {
          if (this.type === 'archer') return this.combo;
          if (this.type === 'fire') return this.fireCombo;
          if (this.type === 'laser') return this.laserCombo;
          if (this.type === 'ice') return this.iceCombo;
          if (this.type === 'lightning') return this.lightningCombo;
          return 1;
        }
        arrowAttack(targets, bullets, comboIdx) {
          const target = targets[0];
          if (!target) return;
          const baseAngle = Math.atan2(target.position.y - this.position.y, target.position.x - this.position.x);
          const angleStep = 0.14; // å­å¼¹é—´éš”è§’åº¦
          const n = this.bulletCount;
          if (n % 2 === 1) {
            const center = (n - 1) / 2;
            for (let i = 0; i < n; i++) {
              const angle = baseAngle + (i - center) * angleStep + (comboIdx ? (comboIdx-0.5)*0.08 : 0);
              bullets.push(new Bullet(this.position, angle, 16, this.damage, "arrow", 1, this.type, this.bulletSplit, 0, 0, null, comboIdx));
            }
          } else {
            const leftCenter = n/2 - 1;
            for (let i = 0; i < n; i++) {
              const angle = baseAngle + (i - leftCenter) * angleStep;
              bullets.push(new Bullet(this.position, angle, 16, this.damage, "arrow", 1, this.type, this.bulletSplit, 0, 0, null, comboIdx));
            }
          }
        }
        laserAttack(targets, effects, comboIdx) {
          const target = targets[0];
          if (!target) return;
          const from = {x: this.position.x, y: this.position.y};
          // è®¡ç®—æ¿€å…‰æ–¹å‘
          const dx = target.position.x - this.position.x;
          const dy = target.position.y - this.position.y;
          const angle = Math.atan2(dy, dx);
          // è®¡ç®—ç»ˆç‚¹ï¼šå»¶é•¿åˆ°å±å¹•è¾¹ç•Œ
          let t = 10000; // è¶³å¤Ÿå¤§
          let tx = from.x + Math.cos(angle) * t;
          let ty = from.y + Math.sin(angle) * t;
          // æ‰¾åˆ°ä¸å±å¹•è¾¹ç•Œçš„äº¤ç‚¹
          // æ¨ªå‘è¾¹ç•Œ
          if (Math.abs(Math.cos(angle)) > 1e-3) {
            let tx1 = (0 - from.x) / Math.cos(angle);
            let tx2 = (STAGE_WIDTH - from.x) / Math.cos(angle);
            let ty1 = from.y + tx1 * Math.sin(angle);
            let ty2 = from.y + tx2 * Math.sin(angle);
            if (tx1 > 0 && ty1 >= 0 && ty1 <= STAGE_HEIGHT) { tx = 0; ty = ty1; t = tx1; }
            if (tx2 > 0 && ty2 >= 0 && ty2 <= STAGE_HEIGHT && tx2 < t) { tx = STAGE_WIDTH; ty = ty2; t = tx2; }
          }
          // çºµå‘è¾¹ç•Œ
          if (Math.abs(Math.sin(angle)) > 1e-3) {
            let ty1 = (0 - from.y) / Math.sin(angle);
            let ty2 = (STAGE_HEIGHT - from.y) / Math.sin(angle);
            let tx1 = from.x + ty1 * Math.cos(angle);
            let tx2 = from.x + ty2 * Math.cos(angle);
            if (ty1 > 0 && tx1 >= 0 && tx1 <= STAGE_WIDTH && ty1 < t) { tx = tx1; ty = 0; t = ty1; }
            if (ty2 > 0 && tx2 >= 0 && tx2 <= STAGE_WIDTH && ty2 < t) { tx = tx2; ty = STAGE_HEIGHT; t = ty2; }
          }
          const to = {x: tx, y: ty};
          const width = this.laserWidth * (1 + this.laserWidthBonus);
          const duration = this.laserDuration * (1 + this.laserDurationBonus);
          effects.push({
            type: "laser",
            from, to,
            start: Date.now(),
            duration,
            width,
            tick: 0,
            hero: this
          });
        }
        fireballAttack(targets, bullets, effects, comboIdx) {
          const target = targets[0];
          if (!target) return;
          const fixedExplosionRadius = 27 * 2;
          bullets.push(new Bullet(this.position, Math.atan2(target.y - this.position.y, target.x - this.position.x), 13, this.damage * (1 + this.fireDamageBonus), "fireball", 1, this.type, 0, fixedExplosionRadius, 0, null, comboIdx));
        }
        iceAttack(targets, bullets, effects, comboIdx) {
          const target = targets[0];
          if (!target) return;
          bullets.push(new Bullet(this.position, Math.atan2(target.y - this.position.y, target.x - this.position.x), 13, 3 * (1 + this.iceDamageBonus), "ice", 3, this.type, 0, 0, this.iceFreeze, null, comboIdx));
        }
        lightningAttack(targets, effects, comboIdx) {
          const target = targets[0];
          if (!target) return;
          effects.push({
            type: "lightning",
            x: target.position.x,
            y: target.position.y,
            start: Date.now(),
            duration: 400,
            hero: this,
            comboIdx: comboIdx
          });
          effects.push({
            type: "lightning-flash",
            x: target.position.x,
            y: target.position.y,
            start: Date.now(),
            duration: 200,
            comboIdx: comboIdx
          });
          // èŒƒå›´ä¼¤å®³
          const radius = target.radius * 2;
          let dmg = 5 * (1 + this.lightningDamageBonus);
          enemies.forEach(e2 => {
            if (e2.alive && e2.visible && Math.sqrt((e2.position.x - target.position.x) ** 2 + (e2.position.y - target.position.y) ** 2) <= radius) {
              addDamageNumber(e2.position.x, e2.position.y-30, Math.round(dmg), "lightning", "");
              e2.takeDamage(dmg, "lightning", "");
              if (!e2.isBoss && this.lightningStun > 0) {
                e2.stunUntil = Math.max(e2.stunUntil || 0, Date.now() + 1000 * this.lightningStun);
              }
              if (!e2.isBoss) e2.paralyzeUntil = Date.now() + 3000;
            }
          });
        }
        findTarget(enemies) {
          if (this._lockedTarget) return this._lockedTarget;
          // å…œåº•ï¼šåŸæœ‰é€»è¾‘
          const left = this.rangeLeft();
          const right = this.rangeRight();
          const top = this.rangeTop();
          const bottom = this.rangeBottom();
          let candidates = enemies.filter(e =>
            e.visible &&
            e.position.x > left &&
            e.position.x < right &&
            e.position.y > top &&
            e.position.y < bottom
          );
          if (candidates.length === 0) return null;
          return candidates.reduce((maxE, e) => (e.position.y > maxE.position.y ? e : maxE), candidates[0]);
        }
      }

      // ================== å­å¼¹ç±» ==================
      class Bullet {
        constructor(position, angle, speed, damage, type, pierce=1, heroType, split=0, explosionRadius=0, freeze=0, excludeTarget=null, comboIdx) {
          this.position = { x: position.x, y: position.y };
          // ä¿®æ­£ï¼šå­å¼¹é€Ÿåº¦ä¸å†å› 2å€é€Ÿè€ŒåŠ å¿«ï¼Œå§‹ç»ˆç”¨åŸå§‹speed
          let speedBuff = speed;
          // å°„æ‰‹å“¥å­å¼¹é€Ÿåº¦åŠ å¿«30%
          if (heroType === 'archer') {
            speedBuff = speed * 1.3;
          }
          this.velocity = { x: speedBuff * Math.cos(angle), y: speedBuff * Math.sin(angle) };
          this.damage = damage;
          this.radius = type === 'fireball' ? 10 : (type === 'ice' ? 9 : 8);
          this.type = type;
          this.active = true;
          this.pierce = pierce;
          this.hitEnemies = new Set();
          this.heroType = heroType;
          this.split = split;
          this.explosionRadius = explosionRadius;
          this.freeze = freeze;
          this.bulletSplitTimes = 0;
          this.excludeTarget = excludeTarget; // æ–°å¢ï¼šåˆ†è£‚å­å¼¹ä¸èƒ½å‘½ä¸­åŸç›®æ ‡
          this.comboIdx = typeof comboIdx === 'number' ? comboIdx : 0;
        }
        update() {
          this.position.x += this.velocity.x;
          this.position.y += this.velocity.y;
          if (this.position.x < 0 || this.position.x > STAGE_WIDTH ||
              this.position.y < 0 || this.position.y > STAGE_HEIGHT) {
            this.active = false;
          }
        }
      }

      // ================== æ•Œäººç±» ==================
      class Enemy {
        constructor(x, y, hp, scale=1, isBoss=false, appearTime=0, enemyType='normal') {
          this.position = { x, y };
          if (isBoss) {
            this.radius = 18 * scale;
          } else if (enemyType === 'fast') {
            this.radius = 9 * scale;
            this.hp = Math.round(hp * 2 / 3);
            this.maxHp = this.hp;
          } else if (enemyType === 'tank') {
            this.radius = 27 * scale;
            this.hp = Math.round(hp * 2);
            this.maxHp = this.hp;
          } else {
            this.radius = 18 * scale;
          }
          this.hp = hp;
          this.maxHp = hp;
          this.alive = true;
          this.type = enemyType;
          // æ•Œäººé€Ÿåº¦è°ƒæ•´ï¼šébossåŠ å¿«0.2ï¼Œbosså‡æ…¢0.3
          if (isBoss) {
            this.speed = 0.3 * 2/3 * 4/3 + 0.3;
          } else if (enemyType === 'fast') {
            this.speed = 0.9 * 2/3 * 4/3 + 0.2;
            this.hp = Math.round(hp * 2 / 3);
            this.maxHp = this.hp;
          } else if (enemyType === 'tank') {
            this.speed = 0.3 * 2/3 * 4/3 + 0.2;
            this.hp = Math.round(hp * 2);
            this.maxHp = this.hp;
          } else {
            this.speed = 0.6 * 2/3 * 4/3 + 0.2;
          }
          this.slowUntil = 0;
          this.stunUntil = 0;
          this.frozenUntil = 0;
          this.isBoss = isBoss;
          this.appearTime = appearTime; // æ–°å¢ï¼šå‡ºç°æ—¶é—´æˆ³
          this.visible = false;
          this.burnUntil = 0; // ç‡ƒçƒ§ç»“æŸæ—¶é—´
          this.burnDps = 0;   // ç‡ƒçƒ§ä¼¤å®³/ç§’
          this.lastBurnTick = 0;
          this.paralyzeUntil = 0; // éº»ç—¹ç»“æŸæ—¶é—´
        }
        update(now) {
          if (!this.visible) {
            if (now < this.appearTime) return;
            this.visible = true;
          }
          let speed = this.speed * speedMultiplier;
          if (!this.isBoss) {
            if (Date.now() < this.slowUntil) speed *= 0.5;
            if (Date.now() < this.stunUntil) speed = 0;
            if (Date.now() < this.frozenUntil) speed = 0;
          }
          this.position.y += speed;
          if (this.position.y > STAGE_HEIGHT) this.alive = false;
          // ç‡ƒçƒ§ä¼¤å®³
          if (!this.isBoss) {
            if (Date.now() < this.burnUntil) {
              if (!this.lastBurnTick) this.lastBurnTick = Date.now();
              while (this.lastBurnTick + 1000/speedMultiplier <= Date.now() && this.alive) {
                this.lastBurnTick += 1000/speedMultiplier;
                let dmg = Math.max(1, Math.round(this.burnDps));
                this.hp -= dmg;
                addDamageNumber(this.position.x, this.position.y-40, dmg, "fire", "");
              }
            } else {
              this.burnDps = 0;
              this.lastBurnTick = 0;
            }
          }
        }
        // å¤„ç†éº»ç—¹åŠ ä¼¤
        takeDamage(amount, heroType, extraText, comboIdx=0) {
          let baseDmg = Math.max(1, Math.round(amount));
          let isParalyze = !this.isBoss && Date.now() < this.paralyzeUntil;
          let paralyzeDmg = 0;
          if (isParalyze) {
            paralyzeDmg = Math.max(1, Math.round(baseDmg * 0.2));
          }
          let dmg = baseDmg + paralyzeDmg;
          this.hp -= dmg;
          // ä¸»ä¼¤å®³æ•°å­—ï¼Œéº»ç—¹æ—¶é¢å¤–åŠ æˆæ˜¾ç¤ºä¸º"é¢å¤–x"
          let extraStr = '';
          if (isParalyze && paralyzeDmg > 0) {
            extraStr = 'é¢å¤–' + paralyzeDmg;
          }
          addDamageNumber(this.position.x, this.position.y-30-20*(comboIdx||0), baseDmg, heroType, extraText||extraStr);
        }
      }

      // ================== ç©å®¶ç±» ==================
      class Player {
        constructor() {
          this.exp = 0;
          this.level = 1;
          this.heroes = [new Hero(HERO_CONFIGS[0], STAGE_WIDTH/2)];
          this.upgradeCounts = {};
          this.expThreshold = [Math.max(1, 5 + (this.level-1) - 2)]; // æ¯çº§+1ï¼ŒåŸºç¡€å€¼-2
          this.killCount = 0;
          this.life = 10;
          this.updateExpThreshold(1);
          this.upgradeHistory = [];
        }
        updateExpThreshold() {
          // æ¯çº§+1
          this.expThreshold = [Math.max(1, 5 + (this.level-1) - 2)];
        }
        gainExp(amount) {
          this.exp += amount;
          while (this.exp >= this.expThreshold[0]) {
            this.exp -= this.expThreshold[0];
            this.level++;
            this.updateExpThreshold();
            showUpgrade(this);
          }
        }
        addHero(type) {
          if (this.heroes.find(h => h.type === type)) return;
          const idx = HERO_CONFIGS.findIndex(cfg => cfg.type === type);
          const positions = getHeroPositions(this.heroes.length + 1);
          // æ–°å¢è‹±é›„æ—¶ä¿ç•™åŸæœ‰è‹±é›„å±æ€§
          const newHero = new Hero(HERO_CONFIGS[idx], positions[this.heroes.length]);
          this.heroes.push(newHero);
          this.heroes.forEach((hero, i) => hero.position.x = positions[i]);
        }
      }

      // ================== æ³¢æ¬¡ç®¡ç† ==================
      class WaveManager {
        constructor() {
          this.currentWave = 0;
          this.totalWaves = 20;
        }
        nextWave() {
          this.currentWave++;
        }
        spawnWave() {
          const enemies = [];
          const count = 5 + (this.currentWave - 1);
          // æ¯2æ³¢æå‡åŸºç¡€å€¼çš„20%è¡€é‡
          let baseHp = 6 + Math.floor((this.currentWave-1)/2) * 6 * 0.2;
          const segments = Math.min(count, 8);
          const now = Date.now();
          const interval = 20000; // 20ç§’
          const enemyTypes = ['normal','fast','tank'];
          for (let i = 0; i < count; i++) {
            const seg = i % segments;
            const segWidth = STAGE_WIDTH / segments;
            const x = segWidth * seg + segWidth/2 + (Math.random()-0.5)*segWidth*0.6;
            const yBase = 20 + seg * 30;
            const y = yBase + Math.random()*20 + STAGE_TOP_OFFSET;
            // å‡åŒ€åˆ†å¸ƒåœ¨Nç§’å†…
            const appearTime = now + Math.floor(i * interval / count);
            // éšæœºç±»å‹
            const type = enemyTypes[Math.floor(Math.random()*enemyTypes.length)];
            enemies.push(new Enemy(x, y, baseHp, 1, false, appearTime, type));
          }
          // ç‰¹æ®Šå¤§æ€ªåˆ†æ•£x/y
          const bossWaves = [5, 10, 15, 20];
          if (bossWaves.includes(this.currentWave)) {
            const bossCount = 1;
            for (let i = 0; i < bossCount; i++) {
              // Bossè¡€é‡ä¹ŸéšåŸºç¡€å€¼é€’å¢
              let bossBase = 50;
              if (this.currentWave === 10) bossBase = 100;
              if (this.currentWave === 15) bossBase = 150;
              if (this.currentWave === 20) bossBase = 200;
              let bossHp = bossBase + Math.floor((this.currentWave-1)/2) * bossBase * 0.2;
              let bossScale = 1.5;
              if (this.currentWave === 10) bossScale = 2;
              if (this.currentWave === 15) bossScale = 2.5;
              if (this.currentWave === 20) bossScale = 3;
              let y = 100 + i * 120 + Math.random()*60 + STAGE_TOP_OFFSET;
              let x = STAGE_WIDTH/(bossCount+1)*(i+1);
              enemies.push(new Enemy(x, y, bossHp, bossScale, true));
            }
          }
          return enemies;
        }
      }

      // ================== å‡çº§é€‰é¡¹ç”Ÿæˆ ==================
      function getUpgradeOptions(player) {
        const options = [];
        const counts = player.upgradeCounts;
        const has = type => player.heroes.find(h => h.type === type);
        if (!has('fire') && !counts['fire_spawn']) options.push({text: 'ç«ç„°å“¥å‡ºåœº<br/>(èŒƒå›´ã€ä¼¤å®³)', key: 'fire_spawn'});
        if (has('fire') && (counts['fire_damage']||0)<10) options.push({text: 'ç«ç„°å“¥ä¼¤å®³å¢åŠ 60%', key: 'fire_damage'});
        if (has('fire') && (counts['fire_explosion']||0)<2) options.push({text: 'ç«ç„°å“¥çˆ†ç‚¸èŒƒå›´æ‰©å¤§50%', key: 'fire_explosion'});
        if (!has('laser') && !counts['laser_spawn']) options.push({text: 'æ¿€å…‰å“¥å‡ºåœº<br/>(ç›´çº¿ã€ä¼¤å®³)', key: 'laser_spawn'});
        if (has('laser') && (counts['laser_damage']||0)<10) options.push({text: 'æ¿€å…‰å“¥ä¼¤å®³å¢åŠ 60%', key: 'laser_damage'});
        if (has('laser') && (counts['laser_duration']||0)<2) options.push({text: 'æ¿€å…‰å“¥æŒä¹…è¾“å‡º', key: 'laser_duration'});
        if (has('laser') && (counts['laser_width']||0)<2) options.push({text: 'æ¿€å…‰å“¥å…‰æŸå˜ç²—50%', key: 'laser_width'});
        if (!has('lightning') && !counts['lightning_spawn']) options.push({text: 'æ‰“é›·å“¥å‡ºåœº<br/>(èŒƒå›´ã€å¢ä¼¤)', key: 'lightning_spawn'});
        if (has('lightning') && (counts['lightning_damage']||0)<10) options.push({text: 'æ‰“é›·å“¥ä¼¤å®³å¢åŠ 60%', key: 'lightning_damage'});
        if (has('lightning') && (counts['lightning_stun']||0)<2) options.push({text: 'æ‰“é›·å“¥é™„å¸¦æ™•çœ©', key: 'lightning_stun'});
        if (!has('ice') && !counts['ice_spawn']) options.push({text: 'å¯’å†°å“¥å‡ºåœº<br/>(å‡é€Ÿã€ç©¿é€)', key: 'ice_spawn'});
        if (has('ice') && (counts['ice_damage']||0)<10) options.push({text: 'å¯’å†°å“¥ä¼¤å®³å¢åŠ 60%', key: 'ice_damage'});
        if (has('ice') && (counts['ice_freeze']||0)<2) options.push({text: 'å¯’å†°å“¥é™„å¸¦å†»ç»“', key: 'ice_freeze'});
        if ((counts['archer_bullet']||0)<2) options.push({text: 'å°„æ‰‹å“¥å­å¼¹+1', key: 'archer_bullet'});
        if ((counts['archer_damage']||0)<10) options.push({text: 'å°„æ‰‹å“¥ä¼¤å®³å¢åŠ 60%', key: 'archer_damage'});
        if ((counts['archer_split']||0)<2) options.push({text: 'å°„æ‰‹å“¥å­å¼¹åˆ†è£‚+1', key: 'archer_split'});
        return shuffle(options).slice(0, 3);
      }

      // ================== å‡çº§å¼¹çª—ï¼ˆç‚¹å‡»å¼ï¼‰ ==================
      function showUpgrade(player, isBossReward) {
        const panel = document.getElementById('upgrade-panel');
        const optionsDiv = document.getElementById('upgrade-options');
        optionsDiv.innerHTML = '';
        // ä¿®æ”¹æ ‡é¢˜
        const title = panel.querySelector('#upgrade-box h2');
        if (isBossReward) {
          title.innerText = 'BOSSå¥–åŠ±';
        } else {
          title.innerText = 'è¯·é€‰æ‹©å‡çº§';
        }
        const options = getUpgradeOptions(player);
        // æ›¿æ¢è‹±é›„åç§°ä¸ºicon
        function replaceHeroNameWithIcon(text) {
          return text
            .replace(/å°„æ‰‹å“¥/g, HERO_ICONS.archer + ' ')
            .replace(/ç«ç„°å“¥/g, HERO_ICONS.fire + ' ')
            .replace(/æ¿€å…‰å“¥/g, HERO_ICONS.laser + ' ')
            .replace(/å¯’å†°å“¥/g, HERO_ICONS.ice + ' ')
            .replace(/æ‰“é›·å“¥/g, HERO_ICONS.lightning + ' ');
        }
        options.forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'upgrade-btn';
          btn.innerHTML = replaceHeroNameWithIcon(opt.text); // ç”¨icon+æ–‡æœ¬
          btn.style.whiteSpace = 'normal';
          btn.style.lineHeight = '1.4';
          btn.onclick = () => {
            panel.style.display = 'none';
            player.upgradeCounts[opt.key] = (player.upgradeCounts[opt.key]||0)+1;
            // è®°å½•å‡çº§å†å²
            player.upgradeHistory.push({
              key: opt.key,
              text: opt.text,
              time: new Date().toLocaleTimeString()
            });
            // å¤„ç†å‡çº§æ•ˆæœ
            if (opt.key === 'fire_spawn') player.addHero('fire');
            if (opt.key === 'fire_combo') player.heroes.find(h=>h.type==='fire').fireCombo++;
            if (opt.key === 'fire_damage') player.heroes.find(h=>h.type==='fire').fireDamageBonus += 0.6;
            if (opt.key === 'fire_explosion') player.heroes.find(h=>h.type==='fire').fireExplosionBonus += 0.5;
            if (opt.key === 'laser_spawn') player.addHero('laser');
            if (opt.key === 'laser_damage') player.heroes.find(h=>h.type==='laser').laserDamage *= 1.6;
            if (opt.key === 'laser_duration') player.heroes.find(h=>h.type==='laser').laserDurationBonus += 0.5;
            if (opt.key === 'laser_width') player.heroes.find(h=>h.type==='laser').laserWidthBonus += 0.5;
            if (opt.key === 'lightning_spawn') player.addHero('lightning');
            if (opt.key === 'lightning_damage') player.heroes.find(h=>h.type==='lightning').lightningDamageBonus += 0.6;
            if (opt.key === 'lightning_combo') player.heroes.find(h=>h.type==='lightning').lightningCombo++;
            if (opt.key === 'lightning_stun') player.heroes.find(h=>h.type==='lightning').lightningStun++;
            if (opt.key === 'ice_spawn') player.addHero('ice');
            if (opt.key === 'ice_damage') player.heroes.find(h=>h.type==='ice').iceDamageBonus += 0.6;
            if (opt.key === 'ice_combo') player.heroes.find(h=>h.type==='ice').iceCombo++;
            if (opt.key === 'ice_freeze') player.heroes.find(h=>h.type==='ice').iceFreeze++;
            if (opt.key === 'archer_bullet') player.heroes.find(h=>h.type==='archer').bulletCount++;
            if (opt.key === 'archer_damage') player.heroes.find(h=>h.type==='archer').damage *= 1.6;
            if (opt.key === 'archer_split') player.heroes.find(h=>h.type==='archer').bulletSplit++;
          };
          optionsDiv.appendChild(btn);
        });
        panel.style.display = 'flex';
      }

      // ================== æ”»å‡»èŒƒå›´æ˜¾ç¤ºæ§åˆ¶ ==================
      let selectedHeroIdx = null;

      // canvaså†…iconå‚æ•°
      const iconPause = { x: STAGE_WIDTH-38, y: STAGE_HEIGHT*0.22, r: 22 };
      const iconSpeed = { x: STAGE_WIDTH-38, y: STAGE_HEIGHT*0.5, r: 22 };
      const iconHistory = { x: STAGE_WIDTH-38, y: STAGE_HEIGHT*0.78, r: 22 };

      // å·¥å…·å‡½æ•°ï¼šåˆ¤æ–­ç‚¹æ˜¯å¦åœ¨åœ†å†…
      function inCircle(mx, my, cx, cy, r) {
        return (mx-cx)*(mx-cx)+(my-cy)*(my-cy) <= r*r;
      }

      // äº‹ä»¶ç›‘å¬ passive å…¼å®¹
      let supportsPassive = false;
      try {
        window.addEventListener("test", null, Object.defineProperty({}, 'passive', {
          get: function() { supportsPassive = true; }
        }));
      } catch(e) {}

      // ç»Ÿä¸€æŒ‰é’®äº¤äº’ï¼ŒPCç«¯click+ç§»åŠ¨ç«¯touchend
      function getButtonCentersLogic() {
        return {
          pause: { x: 750 - 38, y: 1624 * 0.22, r: 22 },
          speed: { x: 750 - 38, y: 1624 * 0.29, r: 22 },
          history: { x: 750 - 38, y: 1624 * 0.36, r: 22 }
        };
      }
      function getLogicPosFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        let x, y;
        if (e.type === 'touchend') {
          const touch = e.changedTouches[0];
          x = (touch.clientX - rect.left) * (750 / rect.width);
          y = (touch.clientY - rect.top) * (1624 / rect.height);
        } else {
          x = (e.clientX - rect.left) * (750 / rect.width);
          y = (e.clientY - rect.top) * (1624 / rect.height);
        }
        return {x, y};
      }
      canvas.addEventListener('click', function(e) {
        const {x, y} = getLogicPosFromEvent(e);
        handleButtonEventCoreLogic(x, y, e);
      });
      canvas.addEventListener('touchend', function(e) {
        const {x, y} = getLogicPosFromEvent(e);
        handleButtonEventCoreLogic(x, y, e);
      }, supportsPassive ? {passive: false} : false);
      function handleButtonEventCoreLogic(mx, my, e) {
        console.log('handleButtonEventCoreLogic è§¦å‘ï¼Œmx=', mx, 'my=', my);
        const { pause, speed, history } = getButtonCentersLogic();
        if (inCircle(mx, my, pause.x, pause.y, pause.r)) {
          console.log('è¿›å…¥æš‚åœæŒ‰é’®åˆ¤å®šåˆ†æ”¯');
          window.paused = !window.paused;
          console.log('æš‚åœæŒ‰é’®ç‚¹å‡»åï¼Œwindow.paused=' + window.paused);
          if (!window.paused) {
            if (!gameLoopRunning) {
              gameLoopRunning = true;
              gameLoopReqId = requestAnimationFrame(gameLoop);
            }
          } else {
            gameLoopRunning = false;
            if (gameLoopReqId) {
              cancelAnimationFrame(gameLoopReqId);
              gameLoopReqId = null;
            }
          }
          e.preventDefault && e.preventDefault();
          return;
        }
        if (inCircle(mx, my, speed.x, speed.y, speed.r)) {
          console.log('[æŒ‰é’®è°ƒè¯•] å‘½ä¸­2xæŒ‰é’®');
          speedMultiplier = speedMultiplier === 1 ? 2 : 1;
          e.preventDefault && e.preventDefault();
          return;
        }
        if (inCircle(mx, my, history.x, history.y, history.r)) {
          console.log('[æŒ‰é’®è°ƒè¯•] å‘½ä¸­å†å²æŒ‰é’®');
          const counts = {};
          player.upgradeHistory.forEach(item => {
            if (!counts[item.text]) counts[item.text] = 0;
            counts[item.text]++;
          });
          let html = '';
          if (player.upgradeHistory.length === 0) {
            html = '<div style="color:#aaa;">æš‚æ— å‡çº§è®°å½•</div>';
          } else {
            html = '<ul style="padding-left:1.2em;">';
            Object.keys(counts).forEach(text => {
              html += `<li><b>${text}</b> <span style=\"color:#6cf;\">x${counts[text]}</span></li>`;
            });
            html += '</ul>';
            html += '<hr style="border:1px solid #333;">';
            html += '<div style="font-size:13px;color:#aaa;">è¯¦ç»†è®°å½•ï¼š</div>';
            html += '<ol style="padding-left:1.2em;">';
            player.upgradeHistory.forEach(item => {
              html += `<li>${item.time} - ${item.text}</li>`;
            });
            html += '</ol>';
          }
          historyList.innerHTML = html;
          historyPanel.style.display = 'flex';
          e.preventDefault && e.preventDefault();
          return;
        }
        // è‹±é›„é€‰ä¸­é€»è¾‘
        let found = false;
        player.heroes.forEach((hero, idx) => {
          const dx = mx - hero.position.x;
          const dy = my - hero.position.y;
          if (dx*dx + dy*dy <= 22*22) {
            if (selectedHeroIdx === idx) {
              selectedHeroIdx = null;
            } else {
              selectedHeroIdx = idx;
            }
            found = true;
          }
        });
        if (!found) selectedHeroIdx = null;
        e.preventDefault && e.preventDefault();
      }

      // ================== æ¸¸æˆä¸»å¾ªç¯ ==================
      const player = new Player();
      const waveManager = new WaveManager();
      let enemies = waveManager.spawnWave();
      let bullets = [];
      let effects = [];
      let lastWaveTime = Date.now();
      let lastAutoWaveTime = Date.now();

      // ä¿®å¤åˆ·æ€ªé€»è¾‘ï¼Œé¿å…å¤šæ³¢åŒæ—¶ç”Ÿæˆ
      let wavePending = false;
      let nextWaveTime = 0;
      let gameStarted = false;
      let gameStartTime = 0;
      let gameOver = false;

      // å¼€å§‹æ¸¸æˆæŒ‰é’®é€»è¾‘ï¼ŒcurrentWaveåˆå§‹åŒ–ä¸º0ï¼Œç‚¹å‡»åè®¾ä¸º1å¹¶ç”Ÿæˆç¬¬ä¸€æ³¢
      const startBtn = document.getElementById('start-btn');
      const startScreen = document.getElementById('start-screen');
      startBtn.onclick = function() {
        startScreen.style.display = 'none';
        gameStarted = true;
        waveManager.currentWave = 0;
        player.updateExpThreshold();
        player.killCount = 0;
        waveManager.nextWave();
        enemies = waveManager.spawnWave();
        wavePending = true;
        nextWaveTime = Date.now() + 10000;
        gameStartTime = Date.now();
        fixCanvasDpi(canvas); // ç¡®ä¿å‚æ•°åŒæ­¥
        if (!gameLoopRunning) {
          gameLoopRunning = true;
          gameLoopReqId = requestAnimationFrame(gameLoop);
        }
      }
      // 2å€é€Ÿæ§åˆ¶
      let speedMultiplier = 1;
      // æš‚åœåŠŸèƒ½ï¼ˆå…¨å±€å”¯ä¸€ï¼Œç»‘å®šåˆ°windowï¼‰
      window.paused = false;
      let lastGameNow = Date.now();
      let gameLoopRunning = false;
      let gameLoopReqId = null;
      function gameLoop() {
        if (!gameLoopRunning) return;
        gameLoopReqId = requestAnimationFrame(gameLoop);
        let now;
        if (window.paused || document.getElementById('upgrade-panel').style.display === 'flex' || gameOver) {
          now = lastGameNow;
          draw(now); // ä¾ç„¶æŒç»­åˆ·æ–°UI
          return;
        } else {
          now = Date.now();
          lastGameNow = now;
        }
        if (!gameStarted) {
          draw(now);
          return;
        }
        // --- æ–°å¢ï¼šæ•°ç»„ä¸Šé™ï¼Œé˜²æ­¢æº¢å‡º ---
        const MAX_ENEMIES = 500, MAX_BULLETS = 500, MAX_EFFECTS = 500;
        if (enemies.length > MAX_ENEMIES) enemies = enemies.slice(enemies.length - MAX_ENEMIES);
        if (bullets.length > MAX_BULLETS) bullets = bullets.slice(bullets.length - MAX_BULLETS);
        if (effects.length > MAX_EFFECTS) effects = effects.slice(effects.length - MAX_EFFECTS);
        // ---
        // --- æ–°å¢ï¼šå¤šè‹±é›„åˆ†é…ç›®æ ‡ï¼Œé¿å…é‡å¤é”å®š ---
        const lockedTargets = new Set();
        player.heroes.forEach(hero => {
          hero._lockedTarget = null;
          // æ‰¾åˆ°æœªè¢«é”å®šçš„æœ€è¿‘ç›®æ ‡
          const left = hero.rangeLeft();
          const right = hero.rangeRight();
          const top = hero.rangeTop();
          const bottom = hero.rangeBottom();
          let candidates = enemies.filter(e =>
            e.visible &&
            e.position.x > left &&
            e.position.x < right &&
            e.position.y > top &&
            e.position.y < bottom &&
            !lockedTargets.has(e)
          );
          if (candidates.length > 0) {
            // è·ç¦»åº•éƒ¨æœ€è¿‘
            let target = candidates.reduce((maxE, e) => (e.position.y > maxE.position.y ? e : maxE), candidates[0]);
            hero._lockedTarget = target;
            lockedTargets.add(target);
          }
        });
        player.heroes.forEach(hero => {
          hero.attack(enemies, bullets, effects);
        });
        effects.forEach(eff => {
          if (eff.type === 'laser') {
            const hero = eff.hero;
            const now = Date.now();
            const t = now - eff.start;
            if (t > eff.duration) return;
            // tickæ¯200ms
            if (!eff.lastTick || now - eff.lastTick >= 200) {
              enemies.forEach(enemy => {
                const a = eff.from, b = eff.to, p = enemy.position;
                const abx = b.x - a.x, aby = b.y - a.y;
                const apx = p.x - a.x, apy = p.y - a.y;
                const abLen = Math.sqrt(abx*abx + aby*aby);
                const proj = (apx*abx + apy*aby) / abLen;
                if (proj < 0 || proj > abLen) return;
                const closest = {x: a.x + abx * proj/abLen, y: a.y + aby * proj/abLen};
                const dist = distance(p, closest);
                if (enemy.visible && dist < eff.width/2 + enemy.radius) {
                  let dmg = hero.laserDamage;
                  enemy.takeDamage(dmg, "laser");
                }
              });
              eff.lastTick = now;
              eff.tick = (eff.tick||0)+1;
            }
          }
        });
        bullets.forEach(b => b.update());
        enemies.forEach(e => e.update(now));
        // æ£€æŸ¥æ•Œäººå‡ºç•Œæ‰£è¡€
        enemies.forEach(enemy => {
          if (!enemy.alive && enemy.position.y > STAGE_HEIGHT) {
            if (enemy.isBoss) player.life -= 5;
            else player.life -= 1;
          }
        });
        enemies = enemies.filter(e => e.alive && e.hp > 0);
        bullets.forEach(bullet => {
          enemies.forEach((enemy, idx) => {
            if (enemy.alive && enemy.visible && bullet.active && !bullet.hitEnemies.has(enemy)) {
              // åˆ†è£‚å­å¼¹ä¸èƒ½å‘½ä¸­åŸç›®æ ‡
              if (bullet.excludeTarget && bullet.excludeTarget === enemy) return;
              const dx = bullet.position.x - enemy.position.x;
              const dy = bullet.position.y - enemy.position.y;
              // æ–°å¢ï¼šé€Ÿåº¦å‹æ•Œäººåˆ¤å®šåŠå¾„åŠ å¤§
              let enemyRadius = enemy.radius;
              if (enemy.type === 'fast') enemyRadius += 4;
              const dist = Math.sqrt(dx*dx + dy*dy);
              if (dist < bullet.radius + enemyRadius) {
                bullet.hitEnemies.add(enemy);
                if (bullet.type === "fireball") {
                  // çˆ†ç‚¸ï¼šä»¥å‘½ä¸­ç›®æ ‡ä¸ºåœ†å¿ƒï¼Œçˆ†ç‚¸åŠå¾„ä¸º3xæ•ŒäººåŠå¾„
                  const explosionRadius = enemy.radius * 3;
                  effects.push({type: "explosion-area", x: enemy.position.x, y: enemy.position.y, r: explosionRadius, start: Date.now(), duration: 200});
                  enemies.forEach(e2 => {
                    if (e2.alive && distance(e2.position, enemy.position) <= explosionRadius) {
                      e2.takeDamage(bullet.damage, "fire");
                      // åœ¨çˆ†ç‚¸/å¼•ç‡ƒå¤„ï¼Œè®¾ç½®burnDpsä¸ºç«ç„°å“¥ä¼¤å®³çš„0.1å€ï¼ŒæŒç»­3ç§’
                      // æ‰¾åˆ°ç«ç„°å“¥
                      const fireHero = player.heroes.find(h=>h.type==='fire');
                      if (fireHero) {
                        if (!e2.isBoss) {
                          e2.burnUntil = Date.now() + 3000;
                          e2.burnDps = Math.max(1, fireHero.damage * (1 + fireHero.fireDamageBonus) * 0.1);
                        }
                      }
                    }
                  });
                  bullet.active = false;
                } else if (bullet.type === "ice") {
                  enemy.takeDamage(bullet.damage, "ice");
                  if (!enemy.isBoss) enemy.slowUntil = Date.now() + 2000;
                  if (!enemy.isBoss && bullet.freeze) enemy.frozenUntil = Date.now() + 1000 * bullet.freeze;
                  effects.push({type: "ice-effect", target: enemy, start: Date.now(), duration: 400});
                  bullet.pierce--;
                  if (bullet.pierce <= 0) bullet.active = false;
                } else if (bullet.type === "arrow") {
                  enemy.takeDamage(bullet.damage, "archer", "", bullet.comboIdx);
                  // å­å¼¹ç¢°æ’éƒ¨åˆ†ï¼Œåˆ†è£‚å­å¼¹ç”Ÿæˆï¼š
                  if (bullet.split > 0 && bullet.bulletSplitTimes < 2) {
                    let usedTargets = new Set([enemy]);
                    for (let s = 0; s < bullet.split; s++) {
                      let minDist = Infinity;
                      let nearest = null;
                      enemies.forEach(e2 => {
                        if (e2.alive && !usedTargets.has(e2)) {
                          const d = Math.sqrt((e2.position.x - enemy.position.x) ** 2 + (e2.position.y - enemy.position.y) ** 2);
                          if (d < minDist) {
                            minDist = d;
                            nearest = e2;
                          }
                        }
                      });
                      let angle;
                      if (nearest) {
                        angle = Math.atan2(nearest.position.y - enemy.position.y, nearest.position.x - enemy.position.x);
                        usedTargets.add(nearest);
                      } else {
                        angle = Math.random() * Math.PI * 2;
                      }
                      // åˆ†è£‚æ¬¡æ•°è¾¾åˆ°2æ—¶ï¼Œåˆ†è£‚å­å¼¹æœ‰0.5sé—´éš”
                      if (bullet.bulletSplitTimes >= 1) {
                        setTimeout(() => {
                          const newBullet = new Bullet(
                            {x: enemy.position.x, y: enemy.position.y},
                            angle,
                            10,
                            bullet.damage * 0.5,
                            "arrow",
                            1,
                            bullet.heroType,
                            0,
                            0,
                            0,
                            enemy, // excludeTarget: åŸç›®æ ‡
                            bullet.comboIdx
                          );
                          newBullet.bulletSplitTimes = bullet.bulletSplitTimes + 1;
                          bullets.push(newBullet);
                        }, s * 500 / speedMultiplier);
                      } else {
                        const newBullet = new Bullet(
                          {x: enemy.position.x, y: enemy.position.y},
                          angle,
                          10,
                          bullet.damage * 0.5,
                          "arrow",
                          1,
                          bullet.heroType,
                          0,
                          0,
                          0,
                          enemy, // excludeTarget: åŸç›®æ ‡
                          bullet.comboIdx
                        );
                        newBullet.bulletSplitTimes = bullet.bulletSplitTimes + 1;
                        bullets.push(newBullet);
                      }
                    }
                  }
                  bullet.active = false;
                }
                if (enemy.hp <= 0) {
                  enemy.alive = false;
                  player.killCount++;
                  // ç»éªŒè·å–
                  if (enemy.isBoss) {
                    // æ€ªç‰©ç›´æ¥å‡1çº§
                    player.exp = 0;
                    player.level++;
                    player.updateExpThreshold();
                    showUpgrade(player, true);
                  } else {
                    player.gainExp(1);
                  }
                }
              }
            }
          });
        });
        // åˆ·æ€ªé€»è¾‘ï¼ˆæ¯20ç§’ä¸€æ³¢ï¼‰
        if (!wavePending && Date.now() >= nextWaveTime) {
          if (waveManager.currentWave < waveManager.totalWaves) {
            if (!window.paused) {
              waveManager.nextWave();
              player.updateExpThreshold();
              player.killCount = 0;
              enemies = enemies.concat(waveManager.spawnWave());
              wavePending = true;
              nextWaveTime = Date.now() + 20000 / speedMultiplier;
            } else {
              // æš‚åœæ—¶ä¸ç”Ÿæˆæ–°æ€ªï¼Œä¹Ÿä¸æ›´æ–°nextWaveTimeï¼Œç­‰æ¢å¤åå†åˆ¤æ–­
              nextWaveTime = Date.now() + 1000; // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
            }
          }
        }
        if (wavePending) {
          wavePending = false;
        }
        // ç¬¬ä¸€æ³¢ç‰¹æ®Šå¤„ç†ï¼š2ç§’åç”Ÿæˆ
        if (waveManager.currentWave === 1 && enemies.length === 0 && Date.now() >= nextWaveTime) {
            enemies = waveManager.spawnWave();
          wavePending = true;
          nextWaveTime = Date.now() + (10000 + Math.random() * 5000);
        }
        draw(now);
        effects = effects.filter(eff => Date.now() - eff.start < eff.duration);
        bullets = bullets.filter(b => b.active);
        // æ¸¸æˆèƒœåˆ©åˆ¤å®š
        if (waveManager.currentWave === waveManager.totalWaves && enemies.length === 0 && !gameOver) {
          showGameOverPanel('win');
          return;
        }
        // æ¸¸æˆå¤±è´¥åˆ¤å®š
        if (player.life <= 0 && !gameOver) {
          showGameOverPanel('fail');
          return;
        }
      }

      function drawFlame(ctx, x, y, scale=1) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-8, -16, -12, -36, 0, -48);
        ctx.bezierCurveTo(12, -36, 8, -16, 0, 0);
        ctx.closePath();
        const grad = ctx.createLinearGradient(0, 0, 0, -48);
        grad.addColorStop(0, "orange");
        grad.addColorStop(0.5, "#ff0");
        grad.addColorStop(1, "#fff");
        ctx.fillStyle = grad;
        ctx.shadowColor = "#ff0";
        ctx.shadowBlur = 18;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-6, -10);
        ctx.bezierCurveTo(-10, -18, -8, -28, -2, -32);
        ctx.bezierCurveTo(-2, -28, -4, -18, -6, -10);
        ctx.closePath();
        ctx.fillStyle = "#ffb300";
        ctx.shadowBlur = 0;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(6, -10);
        ctx.bezierCurveTo(10, -18, 8, -28, 2, -32);
        ctx.bezierCurveTo(2, -28, 4, -18, 6, -10);
        ctx.closePath();
        ctx.fillStyle = "#ffd700";
        ctx.fill();
        ctx.restore();
      }
      function drawIceEffect(ctx, x, y, scale=1) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.beginPath();
        ctx.arc(0, 0, 26, 0, Math.PI*2);
        ctx.strokeStyle = "#aef6ff";
        ctx.lineWidth = 4;
        ctx.setLineDash([6, 4]);
        ctx.globalAlpha = 0.7;
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "#e0f7fa";
        ctx.lineWidth = 2;
        for(let i=0;i<6;i++){
          ctx.save();
          ctx.rotate(Math.PI/3*i);
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.lineTo(0,-18);
          ctx.stroke();
          ctx.restore();
        }
        ctx.restore();
      }

      // ================== æ¸²æŸ“å‡½æ•° ==================
      function drawHeroIcon(ctx, hero) {
        ctx.save();
        ctx.translate(hero.position.x, hero.position.y);
        // å¤–åœˆé«˜å…‰æè¾¹
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI*2);
        ctx.strokeStyle = hero.config.color;
        ctx.shadowColor = hero.config.color;
        ctx.shadowBlur = 18;
        ctx.lineWidth = 4;
        ctx.globalAlpha = 0.45;
        ctx.stroke();
        ctx.restore();
        // ç»Ÿä¸€åº•åº§
        ctx.save();
        ctx.globalAlpha = 0.18;
        ctx.beginPath();
        ctx.arc(0, 18, 20, 0, Math.PI*2);
        ctx.fillStyle = '#222';
        ctx.shadowColor = hero.config.color;
        ctx.shadowBlur = 12;
        ctx.fill();
        ctx.restore();
        // å¤´éƒ¨ç«‹ä½“æ¸å˜
        ctx.save();
        let grad = ctx.createRadialGradient(-6,-8,4, 0,0,16);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(0.18, '#fff');
        grad.addColorStop(0.4, hero.config.color);
        grad.addColorStop(1, '#222');
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 4;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2.5;
        ctx.globalAlpha = 0.8;
        ctx.stroke();
        ctx.restore();
        // ç»†èŠ‚
        switch(hero.type) {
          case 'archer':
            // å¼“
            ctx.save();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(-2, 2, 13, Math.PI*0.7, Math.PI*1.3, false);
            ctx.stroke();
            // ç®­
            ctx.beginPath();
            ctx.moveTo(-8, -10); ctx.lineTo(12, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(12, 0); ctx.lineTo(8, -4); ctx.moveTo(12, 0); ctx.lineTo(8, 4);
            ctx.stroke();
            ctx.restore();
            break;
          case 'laser':
            // å¤´ç›”
            ctx.save();
            ctx.fillStyle = '#ffe066';
            ctx.beginPath();
            ctx.ellipse(0, 0, 16, 18, 0, 0, Math.PI*2);
            ctx.fill();
            // æŠ¤ç›®é•œ
            ctx.fillStyle = '#222';
            ctx.fillRect(-10, -4, 20, 8);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(-10, -4, 20, 8);
            ctx.restore();
            break;
          case 'fire':
            // ç«ç„°å¤´å‘ï¼ˆä¸è¶…å‡ºå¤´éƒ¨iconï¼‰
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.bezierCurveTo(-8, -18, -6, -24, 0, -28);
            ctx.bezierCurveTo(6, -24, 8, -18, 0, -10);
            ctx.closePath();
            let gradF = ctx.createLinearGradient(0, -28, 0, -10);
            gradF.addColorStop(0, '#fffbe0');
            gradF.addColorStop(0.3, '#ffe066');
            gradF.addColorStop(0.7, '#ff9800');
            gradF.addColorStop(1, '#ff6a00');
            ctx.fillStyle = gradF;
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.restore();
            break;
          case 'ice':
            // é›ªèŠ±
            ctx.save();
            ctx.strokeStyle = '#00e0ff';
            ctx.lineWidth = 3;
            for(let i=0;i<6;i++){
              ctx.save();
              ctx.rotate(Math.PI/3*i);
              ctx.beginPath();
              ctx.moveTo(0,0); ctx.lineTo(0,-14);
              ctx.stroke();
              ctx.restore();
            }
            ctx.beginPath();
            ctx.arc(0,0,6,0,Math.PI*2);
            ctx.stroke();
            ctx.restore();
            break;
          case 'lightning':
            // é—ªç”µå¤´é¥°
            ctx.save();
            ctx.strokeStyle = '#fff700';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(-8,-10); ctx.lineTo(0,0); ctx.lineTo(-4,0); ctx.lineTo(8,12);
            ctx.stroke();
            ctx.restore();
            break;
        }
        ctx.restore();
      }
      function drawBullet(ctx, bullet) {
        ctx.save();
        switch (bullet.type) {
          case 'arrow': {
            // å°„æ‰‹å“¥ï¼šç™½è‰²å¸¦è“æè¾¹ç®­å¤´ï¼Œå¸¦æ‹–å°¾
            ctx.save();
            ctx.translate(bullet.position.x, bullet.position.y);
            ctx.rotate(Math.atan2(bullet.velocity.y, bullet.velocity.x));
            // æ‹–å°¾
            let grad = ctx.createLinearGradient(-18, 0, 8, 0);
            grad.addColorStop(0, 'rgba(108,207,255,0.2)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(-18, -3); ctx.lineTo(8, -1); ctx.lineTo(8, 1); ctx.lineTo(-18, 3); ctx.closePath();
            ctx.fill();
            // ç®­å¤´ä¸»ä½“
            ctx.strokeStyle = '#6cf';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(8, 0); ctx.lineTo(-8, -5); ctx.lineTo(-8, 5); ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.restore();
            break;
          }
          case 'fireball': {
            // ç«ç„°å“¥ï¼šæ©™çº¢ç«çƒï¼Œå‘å…‰ï¼Œæ‹–å°¾
            ctx.save();
            ctx.globalAlpha = 0.92;
            let grad = ctx.createRadialGradient(bullet.position.x, bullet.position.y, 0, bullet.position.x, bullet.position.y, 16);
            grad.addColorStop(0, '#fffbe0');
            grad.addColorStop(0.2, '#ffb347');
            grad.addColorStop(0.7, '#ff9800');
            grad.addColorStop(1, '#a85600');
            ctx.shadowColor = '#ff9800';
            ctx.shadowBlur = 18;
            ctx.beginPath();
            ctx.arc(bullet.position.x, bullet.position.y, 13, 0, Math.PI*2);
            ctx.fillStyle = grad;
            ctx.fill();
            // æ‹–å°¾
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.ellipse(bullet.position.x-18*Math.cos(Math.atan2(bullet.velocity.y, bullet.velocity.x)), bullet.position.y-18*Math.sin(Math.atan2(bullet.velocity.y, bullet.velocity.x)), 10, 4, Math.atan2(bullet.velocity.y, bullet.velocity.x), 0, Math.PI*2);
            ctx.fillStyle = '#ffb347';
            ctx.fill();
            ctx.restore();
            break;
          }
          case 'ice': {
            // å¯’å†°å“¥ï¼šå†°è“å…­è¾¹å½¢/é›ªèŠ±å¼¹ï¼Œå‘å…‰ï¼Œæ‹–å°¾
            ctx.save();
            ctx.translate(bullet.position.x, bullet.position.y);
            ctx.rotate(Math.atan2(bullet.velocity.y, bullet.velocity.x));
            ctx.shadowColor = '#00e0ff';
            ctx.shadowBlur = 12;
            ctx.strokeStyle = '#aef6ff';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            for(let i=0;i<6;i++){
              let angle = Math.PI/3*i;
              let x = Math.cos(angle)*9, y = Math.sin(angle)*9;
              if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0,0,4,0,Math.PI*2);
            ctx.fillStyle = '#b3e6ff';
            ctx.fill();
            // æ‹–å°¾
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.ellipse(-14, 0, 7, 3, 0, 0, Math.PI*2);
            ctx.fillStyle = '#aef6ff';
            ctx.fill();
            ctx.restore();
            break;
          }
          case 'laser': {
            // æ¿€å…‰å“¥ï¼šæ¿€å…‰å¤´éƒ¨äº®ç‚¹ï¼ˆæŸ”å’Œç‰ˆï¼‰
            ctx.save();
            ctx.globalAlpha = 0.45;
            ctx.beginPath();
            ctx.arc(bullet.position.x, bullet.position.y, 10, 0, Math.PI*2);
            ctx.fillStyle = '#ffe066';
            ctx.shadowColor = '#ffe066';
            ctx.shadowBlur = 6;
            ctx.fill();
            ctx.restore();
            break;
          }
          case 'lightning': {
            // æ‰“é›·å“¥ï¼šé”¯é½¿çŠ¶é—ªç”µå¼¹ï¼Œå‘å…‰
            ctx.save();
            ctx.translate(bullet.position.x, bullet.position.y);
            ctx.rotate(Math.atan2(bullet.velocity.y, bullet.velocity.x));
            ctx.strokeStyle = '#fff700';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#fff700';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.moveTo(-8, 0);
            ctx.lineTo(-4, -6);
            ctx.lineTo(0, 0);
            ctx.lineTo(4, 6);
            ctx.lineTo(8, 0);
            ctx.stroke();
            ctx.restore();
            break;
          }
          default: {
            // å…œåº•ï¼šç™½è‰²åœ†ç‚¹
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(bullet.position.x, bullet.position.y, 8, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.restore();
      }
      // 1. drawHeartIconå‡½æ•°
      function drawHeartIcon(ctx, x, y, r, value) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x, y + r * 0.3);
        ctx.bezierCurveTo(x - r, y - r * 0.4, x - r, y + r * 0.8, x, y + r);
        ctx.bezierCurveTo(x + r, y + r * 0.8, x + r, y - r * 0.4, x, y + r * 0.3);
        ctx.closePath();
        ctx.fillStyle = '#ff5a5a';
        ctx.shadowColor = '#f88';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.font = 'bold 18px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(value, x, y + r * 0.35);
        ctx.restore();
      }
      function draw(now) {
        console.log('drawæ—¶window.paused=' + window.paused);
        fixCanvasDpi(canvas);
        ctx.clearRect(0, 0, 750, 1624);
        player.heroes.forEach((hero, idx) => {
          drawHeroIcon(ctx, hero);
          ctx.save();
          ctx.font = '16px Arial';
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'center';
          ctx.fillText(hero.name, hero.position.x, hero.position.y + 32);
          ctx.restore();
          // æ”»å‡»èŒƒå›´ï¼ˆä»…é€‰ä¸­è‹±é›„æ˜¾ç¤ºï¼Œä¸”ä¸ºè™šçº¿ï¼Œåº•éƒ¨ä¸è‹±é›„å¯¹é½ï¼‰
          if (selectedHeroIdx === idx) {
            ctx.save();
            ctx.setLineDash([8, 8]);
            ctx.strokeStyle = 'rgba(255,255,0,0.7)';
            ctx.lineWidth = 2;
            ctx.strokeRect(
              hero.rangeLeft(),
              hero.rangeTop(),
              hero.attackRange.width,
              hero.attackRange.height
            );
            ctx.setLineDash([]);
            ctx.restore();
          }
        });
        // æ–°å¢ï¼šè¾“å‡ºæ‰€æœ‰å­å¼¹comboIdx
        bullets.forEach(bullet => {
          drawBullet(ctx, bullet);
        });
        // åªåœ¨æ¸¸æˆå¼€å§‹åç»˜åˆ¶æ•Œäºº
        if (gameStarted) {
        enemies.forEach(enemy => {
          try {
            if (!enemy.visible) return;
            ctx.save();
            // çŠ¶æ€è‰²ä¼˜å…ˆ
            let mainColor = enemy.isBoss ? '#ff9800' : (enemy.type==='fast' ? '#00eaff' : (enemy.type==='tank' ? '#bfa76f' : '#3f3'));
            let grad = null;
            if (!enemy.isBoss && enemy.type === 'fast') {
              // é€Ÿåº¦å‹ä¸‰è§’å½¢ï¼ˆå°–å¤´å‘ä¸‹ï¼‰
          ctx.save();
          ctx.beginPath();
              ctx.moveTo(enemy.position.x, enemy.position.y+enemy.radius); // å°–å¤´å‘ä¸‹
              ctx.lineTo(enemy.position.x-enemy.radius, enemy.position.y-enemy.radius);
              ctx.lineTo(enemy.position.x+enemy.radius, enemy.position.y-enemy.radius);
              ctx.closePath();
              ctx.fillStyle = mainColor;
              ctx.shadowColor = mainColor;
              ctx.shadowBlur = 8;
          ctx.fill();
              ctx.shadowBlur = 0;
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2;
              ctx.stroke();
          ctx.restore();
            } else if (!enemy.isBoss && enemy.type === 'tank') {
              // è‚‰ç›¾å‹ç›¾ç‰Œï¼ˆä¸Šæ–¹ä¸‹å°–ï¼‰
          ctx.save();
              ctx.beginPath();
              ctx.moveTo(enemy.position.x, enemy.position.y-enemy.radius); // é¡¶éƒ¨
              ctx.lineTo(enemy.position.x-enemy.radius, enemy.position.y+enemy.radius*0.5);
              ctx.lineTo(enemy.position.x, enemy.position.y+enemy.radius);
              ctx.lineTo(enemy.position.x+enemy.radius, enemy.position.y+enemy.radius*0.5);
              ctx.closePath();
              ctx.fillStyle = mainColor;
              ctx.shadowColor = mainColor;
              ctx.shadowBlur = 12;
              ctx.fill();
              ctx.shadowBlur = 0;
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2;
              ctx.stroke();
              ctx.restore();
            } else {
              // å…¶ä»–ç±»å‹å’Œboss
              if (enemy.isBoss) {
                grad = ctx.createRadialGradient(enemy.position.x, enemy.position.y, enemy.radius*0.2, enemy.position.x, enemy.position.y, enemy.radius);
                grad.addColorStop(0, '#fffbe0');
                grad.addColorStop(0.3, '#ffb347');
                grad.addColorStop(0.7, '#ff9800');
                grad.addColorStop(1, '#a85600');
              } else {
                grad = ctx.createRadialGradient(enemy.position.x, enemy.position.y, enemy.radius*0.3, enemy.position.x, enemy.position.y, enemy.radius);
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.5, '#7fff7f');
                grad.addColorStop(1, '#3f3');
              }
              // çŠ¶æ€è‰²è¦†ç›–ï¼ˆBossä¸è¢«è¦†ç›–ï¼‰
              if (!enemy.isBoss) {
                if (Date.now() < enemy.frozenUntil) { grad = null; mainColor = '#b3e6ff'; }
                else if (Date.now() < enemy.slowUntil) { grad = null; mainColor = '#0ff'; }
                else if (Date.now() < enemy.stunUntil) { grad = null; mainColor = '#fff700'; }
              }
          ctx.beginPath();
          ctx.arc(enemy.position.x, enemy.position.y, enemy.radius, 0, Math.PI*2);
              ctx.closePath();
              ctx.fillStyle = grad ? grad : mainColor;
              ctx.shadowColor = grad ? (enemy.isBoss ? '#ff9800' : '#7fff7f') : mainColor;
              ctx.shadowBlur = enemy.isBoss ? 24 : 8;
          ctx.fill();
              ctx.shadowBlur = 0;
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2;
              ctx.stroke();
              // Bossä¸“å±åŠ¨æ€ç«ç„°ç¯
              if (enemy.isBoss) {
                let t = Date.now()/400;
                for(let i=0;i<16;i++){
                  let angle = i*Math.PI/8 + t;
                  let r = enemy.radius*1.18 + Math.sin(t*2+i)*3;
                  ctx.save();
                  ctx.globalAlpha = 0.18+0.12*Math.sin(t*2+i);
                  ctx.beginPath();
                  ctx.arc(enemy.position.x+Math.cos(angle)*r, enemy.position.y+Math.sin(angle)*r, 7+2*Math.sin(t*3+i), 0, Math.PI*2);
                  ctx.fillStyle = 'orange';
                  ctx.shadowColor = '#ff9800';
                  ctx.shadowBlur = 12;
                  ctx.fill();
                  ctx.restore();
                }
              }
              // Bosså¤´é¡¶ç‹å† 
              if (enemy.isBoss) {
                ctx.save();
                let crownY = enemy.position.y - enemy.radius - 12;
                ctx.beginPath();
                ctx.moveTo(enemy.position.x-18, crownY+10);
                ctx.lineTo(enemy.position.x-12, crownY-2);
                ctx.lineTo(enemy.position.x-6, crownY+10);
                ctx.lineTo(enemy.position.x, crownY-6);
                ctx.lineTo(enemy.position.x+6, crownY+10);
                ctx.lineTo(enemy.position.x+12, crownY-2);
                ctx.lineTo(enemy.position.x+18, crownY+10);
                ctx.closePath();
                ctx.fillStyle = '#ffe066';
                ctx.shadowColor = '#ffe066';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#bfa600';
                ctx.lineWidth = 2;
                ctx.stroke();
                // ç‹å† å®çŸ³
                ctx.beginPath();
                ctx.arc(enemy.position.x, crownY+2, 3, 0, Math.PI*2);
                ctx.fillStyle = '#ff3b3b';
                ctx.shadowColor = '#ff3b3b';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
              }
            }
            // bossæ€’çœ‰
            if (enemy.isBoss) {
              ctx.save();
              ctx.strokeStyle = '#a85600';
              ctx.lineWidth = 7;
              ctx.beginPath();
              ctx.moveTo(enemy.position.x-enemy.radius*0.6, enemy.position.y-enemy.radius*0.6);
              ctx.lineTo(enemy.position.x-enemy.radius*0.1, enemy.position.y-enemy.radius*0.25);
              ctx.moveTo(enemy.position.x+enemy.radius*0.6, enemy.position.y-enemy.radius*0.6);
              ctx.lineTo(enemy.position.x+enemy.radius*0.1, enemy.position.y-enemy.radius*0.25);
              ctx.stroke();
              ctx.restore();
            }
            // çœ¼ç›
            ctx.save();
            let eyeY = enemy.position.y - enemy.radius*0.2;
            let eyeDX = enemy.radius*0.32;
            ctx.beginPath();
            ctx.ellipse(enemy.position.x-eyeDX, eyeY, enemy.radius*0.16, enemy.radius*0.22, 0, 0, Math.PI*2);
            ctx.ellipse(enemy.position.x+eyeDX, eyeY, enemy.radius*0.16, enemy.radius*0.22, 0, 0, Math.PI*2);
            ctx.fillStyle = enemy.isBoss ? '#ff3b3b' : '#222';
            ctx.shadowColor = enemy.isBoss ? '#ff3b3b' : 'transparent';
            ctx.shadowBlur = enemy.isBoss ? 16 : 0;
            ctx.fill();
            ctx.shadowBlur = 0;
            // bossæ€’çœ‰ï¼ˆæ›´ç²—æ›´å¼¯ï¼‰
            if (enemy.isBoss) {
              ctx.save();
              ctx.strokeStyle = '#a85600';
              ctx.lineWidth = 7;
              ctx.beginPath();
              ctx.moveTo(enemy.position.x-eyeDX, eyeY-enemy.radius*0.22);
              ctx.bezierCurveTo(enemy.position.x-eyeDX*0.7, eyeY-enemy.radius*0.32, enemy.position.x-eyeDX*0.3, eyeY-enemy.radius*0.08, enemy.position.x-eyeDX*0.1, eyeY-enemy.radius*0.05);
              ctx.moveTo(enemy.position.x+eyeDX, eyeY-enemy.radius*0.22);
              ctx.bezierCurveTo(enemy.position.x+eyeDX*0.7, eyeY-enemy.radius*0.32, enemy.position.x+eyeDX*0.3, eyeY-enemy.radius*0.08, enemy.position.x+eyeDX*0.1, eyeY-enemy.radius*0.05);
              ctx.stroke();
              ctx.restore();
            }
            ctx.restore();
            // å˜´å·´
            ctx.save();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = enemy.isBoss ? 6 : 2;
            ctx.beginPath();
            if (enemy.isBoss) {
              ctx.arc(enemy.position.x, enemy.position.y+enemy.radius*0.32, enemy.radius*0.38, Math.PI*0.08, Math.PI*0.92, false);
            } else {
              ctx.arc(enemy.position.x, enemy.position.y+enemy.radius*0.28, enemy.radius*0.18, Math.PI*0.15, Math.PI*0.85, false);
            }
            ctx.stroke();
            ctx.restore();
            // Bossè¡€æ¡
            if (enemy.isBoss) {
              const barW = enemy.radius * 4.2;
              const barH = 16;
              const barX = enemy.position.x - barW/2;
              const barY = enemy.position.y - enemy.radius - 32;
              ctx.save();
              // è¡€æ¡åº•
              ctx.fillStyle = '#2a0000';
              ctx.fillRect(barX, barY, barW, barH);
              // æ®‹è¡€å˜çº¢é—ªçƒ
              let hpPct = Math.max(0, enemy.hp/enemy.maxHp);
              let barColor = hpPct < 0.3 ? (Math.floor(Date.now()/200)%2===0 ? '#ff2222' : '#ff9800') : '#ff9800';
              // æµå…‰æ¸å˜
              let gradBar = ctx.createLinearGradient(barX, barY, barX+barW, barY);
              gradBar.addColorStop(0, barColor);
              gradBar.addColorStop(0.5, '#fff3b0');
              gradBar.addColorStop(1, barColor);
              ctx.fillStyle = gradBar;
              ctx.fillRect(barX, barY, barW * hpPct, barH);
              // è¾¹æ¡†
              ctx.strokeStyle = '#fff3b0';
              ctx.lineWidth = 3;
              ctx.strokeRect(barX, barY, barW, barH);
              // BOSSå­—æ ·å’Œè¡€é‡
              ctx.font = 'bold 20px Arial';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              ctx.lineWidth = 6;
              ctx.strokeStyle = 'rgba(0,0,0,0.7)';
              ctx.strokeText('BOSS', enemy.position.x, barY-4);
              ctx.fillStyle = '#fff';
              ctx.shadowColor = '#ff9800';
              ctx.shadowBlur = 10;
              ctx.fillText('BOSS', enemy.position.x, barY-4);
              ctx.shadowBlur = 0;
              ctx.font = 'bold 16px Arial';
              ctx.fillStyle = '#fff3b0';
              ctx.textBaseline = 'top';
              ctx.strokeStyle = 'rgba(0,0,0,0.7)';
              ctx.lineWidth = 4;
              ctx.strokeText(`${Math.max(0, Math.round(enemy.hp))} / ${enemy.maxHp}`, enemy.position.x, barY+barH+4);
              ctx.fillText(`${Math.max(0, Math.round(enemy.hp))} / ${enemy.maxHp}`, enemy.position.x, barY+barH+4);
              ctx.restore();
            } else {
              // æ™®é€šæ€ªè¡€æ¡
          ctx.fillStyle = '#f44';
          ctx.fillRect(enemy.position.x - 15, enemy.position.y - 28, 30 * (enemy.hp/enemy.maxHp), 4);
            }
            // é€Ÿåº¦å‹åŠ å°é—ªç”µï¼Œè‚‰ç›¾å‹åŠ å°ç›¾ç‰Œ
            if (!enemy.isBoss) {
              if (enemy.type === 'fast') {
                ctx.save();
                ctx.strokeStyle = '#00eaff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(enemy.position.x-8, enemy.position.y-enemy.radius-6);
                ctx.lineTo(enemy.position.x, enemy.position.y-enemy.radius+6);
                ctx.lineTo(enemy.position.x+8, enemy.position.y-enemy.radius-6);
                ctx.stroke();
          ctx.restore();
              } else if (enemy.type === 'tank') {
                ctx.save();
                ctx.strokeStyle = '#bfa76f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(enemy.position.x, enemy.position.y-enemy.radius-6, 7, Math.PI, 0);
                ctx.lineTo(enemy.position.x+7, enemy.position.y-enemy.radius-6);
                ctx.lineTo(enemy.position.x-7, enemy.position.y-enemy.radius-6);
                ctx.stroke();
                ctx.restore();
              }
            }
            ctx.restore();
          } catch(e) { console.error('Enemy draw error:', e); }
        });
        }
        effects.forEach(eff => {
          if (eff.type === "laser") {
            const hero = eff.hero;
            const now = Date.now();
            let alpha = 0.18;
            if (eff.lastTick && now - eff.lastTick < 80) alpha = 0.35;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = "#ffe066";
            ctx.lineWidth = eff.width;
            ctx.beginPath();
            ctx.moveTo(eff.from.x, eff.from.y);
            ctx.lineTo(eff.to.x, eff.to.y);
            ctx.stroke();
            ctx.restore();
          } else if (eff.type === "explosion-area") {
            ctx.save();
            ctx.beginPath();
            ctx.arc(eff.x, eff.y, eff.r, 0, Math.PI*2);
            ctx.fillStyle = "rgba(255,120,0,0.18)";
            ctx.fill();
            ctx.restore();
          } else if (eff.type === "fire-flame") {
            if (eff.target && eff.target.alive) {
              // åˆ¤æ–­æ˜¯å¦åˆšé€ æˆä¼¤å®³ï¼ˆå³lastBurnTickåœ¨200mså†…ï¼‰
              let alpha = 0.5;
              if (eff.target.lastBurnTick && now - eff.target.lastBurnTick < 200) {
                alpha = 1;
              }
              ctx.save();
              ctx.globalAlpha = alpha;
              drawFlame(ctx, eff.target.position.x, eff.target.position.y, 1.5);
              ctx.restore();
            }
          } else if (eff.type === "ice-effect") {
            if (eff.target && eff.target.alive) {
              drawIceEffect(ctx, eff.target.position.x, eff.target.position.y, 1);
            }
          } else if (eff.type === "lightning") {
            ctx.save();
            ctx.strokeStyle = "#fff700";
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(eff.x, eff.y-80);
            ctx.lineTo(eff.x, eff.y+20);
            ctx.stroke();
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(eff.x, eff.y-40);
            ctx.lineTo(eff.x-15, eff.y-10);
            ctx.moveTo(eff.x, eff.y-20);
            ctx.lineTo(eff.x+20, eff.y+10);
            ctx.stroke();
            ctx.restore();
          } else if (eff.type === "lightning-flash") {
            ctx.save();
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(eff.x, eff.y, 40, 0, Math.PI*2);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.restore();
          }
        });
        drawDamageNumbers(ctx);
        // å…ˆç”»ç­‰çº§ã€ç»éªŒã€ç”Ÿå‘½å€¼ï¼Œå†ç”»ç»éªŒæ¡ï¼Œé¿å…è¢«é®æŒ¡
        // ç»éªŒæ¡
        const barX = 20, barY = STAGE_HEIGHT-48, barW = STAGE_WIDTH-40, barH = 18;
        ctx.save();
        // èƒŒæ™¯
        ctx.fillStyle = '#222';
        ctx.strokeStyle = '#6cf';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(barX, barY, barW, barH, 8);
        ctx.fill();
        ctx.stroke();
        // è¿›åº¦
        ctx.save();
        ctx.beginPath();
        ctx.roundRect(barX, barY, barW * (player.exp/(player.expThreshold[0]||1)), barH, 8);
        ctx.clip();
        const grad = ctx.createLinearGradient(barX, barY, barX+barW, barY);
        grad.addColorStop(0, '#6cf');
        grad.addColorStop(1, '#3cf');
        ctx.fillStyle = grad;
        ctx.fillRect(barX, barY, barW, barH);
        ctx.restore();
        // æ–‡å­—
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // æ–‡å­—æè¾¹å¢å¼ºå¯è¯»æ€§
        ctx.lineWidth = 4;
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.strokeText(`Lv.${player.level}  EXP: ${player.exp}/${player.expThreshold[0]||'-'}`, barX+barW/2, barY+barH/2);
        ctx.fillStyle = '#fff';
        ctx.fillText(`Lv.${player.level}  EXP: ${player.exp}/${player.expThreshold[0]||'-'}`, barX+barW/2, barY+barH/2);
        ctx.restore();
        // æ¸¸æˆæ—¶é—´å’Œç”Ÿå‘½å€¼
        if (gameStarted) {
          ctx.save();
          ctx.font = '18px Arial';
          ctx.fillStyle = '#fff';
          const sec = Math.floor((now - gameStartTime) / 1000);
          const min = Math.floor(sec/60);
          const s = sec%60;
          ctx.textAlign = 'left';
          // æ—¶é—´åœ¨å·¦ä¸Š
          ctx.fillText(`æ—¶é—´: ${min}:${s.toString().padStart(2,'0')}`, 20, 32);
          // ç”Ÿå‘½å€¼ç¾åŒ–æ˜¾ç¤ºåœ¨æ—¶é—´ä¸‹æ–¹
          let lifeX = 20, lifeY = 58, heartR = 13;
          for(let i=0;i<player.life;i++) {
            drawHeartIcon(ctx, lifeX + i*30, lifeY, heartR, '');
          }
          ctx.font = 'bold 18px Arial';
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'left';
          ctx.fillText(`${player.life} / 10`, lifeX + player.life*30 + 8, lifeY+2);
          // æ³¢æ¬¡å’Œå‰©ä½™æ•Œäººçºµå‘æ’åˆ—ï¼Œçˆ±å¿ƒå³ä¾§
          ctx.font = '15px Arial';
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'left';
          ctx.fillText(`æ³¢æ¬¡ï¼š${waveManager.currentWave}/${waveManager.totalWaves}`, STAGE_WIDTH/2+30, 32);
          ctx.fillText(`å‰©ä½™æ•Œäººï¼š${enemies.filter(e=>e.visible).length}`, STAGE_WIDTH/2+30, 52);
          ctx.restore();
        }
        // 4. åˆ é™¤ç”»å¸ƒæœ€ä¸Šæ–¹çš„æ³¢æ¬¡å’Œå‰©ä½™æ•Œäººï¼ˆinfo.innerHTML = ...ï¼‰
        info.innerHTML = '';
        // ç»˜åˆ¶æš‚åœå’Œ2å€é€ŸæŒ‰é’®ï¼ˆå³ä¸Šè§’ï¼‰
        const { pause, speed, history } = getButtonCentersLogic();
        // æš‚åœæŒ‰é’®
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(pause.x, pause.y, pause.r, 0, Math.PI*2);
        ctx.fillStyle = '#222';
        ctx.fill();
        ctx.strokeStyle = '#6cf';
        ctx.lineWidth = 2.5;
        ctx.stroke();
        ctx.save();
        ctx.translate(pause.x, pause.y);
        console.log('æš‚åœæŒ‰é’®ç»˜åˆ¶ï¼Œpaused=' + window.paused);
        if (window.paused) {
          // æš‚åœæ—¶æ˜¾ç¤º"æ’­æ”¾"ä¸‰è§’å½¢
          ctx.beginPath();
          ctx.moveTo(-7, -12);
          ctx.lineTo(11, 0);
          ctx.lineTo(-7, 12);
          ctx.closePath();
          ctx.fillStyle = '#6cf';
          ctx.shadowColor = '#6cf';
          ctx.shadowBlur = 10;
          ctx.fill();
        } else {
          // æœªæš‚åœæ—¶æ˜¾ç¤º"æš‚åœ"ä¸¤æ¡ç«–çº¿
          ctx.beginPath();
          ctx.moveTo(-6, -10); ctx.lineTo(-6, 10);
          ctx.moveTo(6, -10); ctx.lineTo(6, 10);
          ctx.strokeStyle = '#6cf';
          ctx.lineWidth = 6;
          ctx.shadowColor = '#6cf';
          ctx.shadowBlur = 10;
          ctx.stroke();
        }
        ctx.restore();
        ctx.restore();
        // 2å€é€ŸæŒ‰é’®
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(speed.x, speed.y, speed.r, 0, Math.PI*2);
        if (speedMultiplier === 2) {
          const t = Date.now() / 400;
          ctx.save();
          ctx.shadowColor = '#6cf';
          ctx.shadowBlur = 18 + 8 * Math.abs(Math.sin(t));
          ctx.strokeStyle = '#6cf';
          ctx.lineWidth = 7;
          ctx.stroke();
          ctx.restore();
          ctx.fillStyle = '#444';
        } else {
          ctx.fillStyle = '#444';
          ctx.strokeStyle = '#6cf';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.fill();
        ctx.font = 'bold 18px Arial';
        ctx.fillStyle = speedMultiplier === 2 ? '#fff' : '#6cf';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('2x', speed.x, speed.y);
        ctx.restore();
        // å†å²æŒ‰é’®
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(history.x, history.y, history.r, 0, Math.PI*2);
        ctx.fillStyle = '#444';
        ctx.fill();
        ctx.strokeStyle = '#6cf';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.font = 'bold 18px Arial';
        ctx.fillStyle = '#6cf';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('å†', history.x, history.y);
        ctx.restore();
        // ç‰ˆæœ¬å·
        ctx.save();
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = '#aaa';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.globalAlpha = 0.85;
        ctx.fillText('7.17 v2', STAGE_WIDTH-16, 12);
        ctx.restore();
      }

      gameLoop();

      // å‡çº§å†å²é¢æ¿é€»è¾‘
      const historyPanel = document.getElementById('history-panel');
      const historyList = document.getElementById('history-list');
      const closeHistory = document.getElementById('close-history');
      closeHistory.onclick = function() {
        historyPanel.style.display = 'none';
      };

      // åˆ é™¤updateLifeBarå‡½æ•°ï¼Œå› ä¸ºå·²ç§»é™¤ç”Ÿå‘½å€¼è¡€æ¡

      // æ¸¸æˆç»“æŸå¼¹çª—é€»è¾‘
      const gameoverPanel = document.getElementById('gameover-panel');
      const gameoverTitle = document.getElementById('gameover-title');
      const gameoverBtns = document.getElementById('gameover-btns');
      function showGameOverPanel(type) {
        gameOver = true;
        window.paused = true;
        if (type === 'win') {
          gameoverTitle.innerText = 'æ­å–œé€šå…³';
          gameoverTitle.className = 'win';
          gameoverBtns.innerHTML = '<button id="go-back-btn">è¿”å›</button>';
        } else {
          gameoverTitle.innerText = 'æ¸¸æˆå¤±è´¥';
          gameoverTitle.className = 'fail';
          gameoverBtns.innerHTML = '<button id="go-back-btn">è¿”å›</button>' +
            '<button id="retry-btn">é‡è¯•</button>';
        }
        gameoverPanel.style.display = 'flex';
        // æŒ‰é’®äº‹ä»¶
        document.getElementById('go-back-btn').onclick = function() {
          gameoverPanel.style.display = 'none';
          resetGameToStartScreen();
        };
        if (type === 'fail') {
          document.getElementById('retry-btn').onclick = function() {
            gameoverPanel.style.display = 'none';
            restartGame();
          };
        }
      }
      // è¿”å›åˆ°å¼€å§‹ç•Œé¢ï¼Œé‡ç½®æ‰€æœ‰çŠ¶æ€
      function resetGameToStartScreen() {
        // é‡ç½®æ‰€æœ‰å…¨å±€å˜é‡å’ŒçŠ¶æ€
        gameStarted = false;
        gameOver = false;
        window.paused = false;
        // é‡æ–°åˆ›å»º playerã€waveManagerã€enemiesã€bulletsã€effects
        window.location.reload(); // ç®€å•ç²—æš´ï¼Œåˆ·æ–°é¡µé¢å³å¯
      }
      // é‡è¯•ï¼Œé‡æ–°å¼€å§‹æ¸¸æˆ
      function restartGame() {
        // é‡ç½®æ‰€æœ‰å…¨å±€å˜é‡å’ŒçŠ¶æ€
        gameStarted = true;
        gameOver = false;
        window.paused = false;
        // é‡æ–°åˆ›å»º playerã€waveManagerã€enemiesã€bulletsã€effects
        // ç›´æ¥åˆ·æ–°é¡µé¢å¹¶è‡ªåŠ¨ç‚¹å‡»å¼€å§‹
        window.location.reload();
        // æ›´ä¼˜é›…çš„åšæ³•æ˜¯é‡ç½®æ‰€æœ‰å¯¹è±¡å¹¶è‡ªåŠ¨å¼€å§‹ï¼Œä½†ä¸ºä¿è¯çŠ¶æ€å½»åº•æ¸…ç†ï¼Œè¿™é‡Œç›´æ¥åˆ·æ–°
      }
    </script>
  </div>
</body>
</html>