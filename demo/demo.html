<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>五英雄技能Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    body { background: #222; color: #fff; margin:0; padding:0; overflow:hidden; }
    canvas {
      background: #333;
      display: block;
      margin: 20px auto;
      cursor: pointer;
      width: 100vw;
      max-width: 400px;
      height: auto;
      touch-action: manipulation;
      border-radius: 12px;
    }
    #info { text-align: center; font-size: 18px; }
    #upgrade-panel {
      position: fixed;
      left: 0; right: 0; top: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #upgrade-box {
      background: #222;
      border: 2px solid #6cf;
      border-radius: 12px;
      padding: 32px 24px;
      min-width: 220px;
      text-align: center;
      box-shadow: 0 0 24px #000;
    }
    #upgrade-box h2 {
      color: #6cf;
      margin-bottom: 18px;
      font-size: 22px;
    }
    .upgrade-btn {
      display: block;
      width: 90%;
      margin: 16px auto;
      padding: 18px;
      font-size: 22px;
      background: #444;
      color: #fff;
      border: 1px solid #6cf;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .upgrade-btn:active {
      background: #6cf;
      color: #222;
    }
  </style>
</head>
<body>
  <div id="info"></div>
  <button id="speed-btn" style="display:block;margin:12px auto 0 auto;padding:10px 28px;font-size:18px;background:#444;color:#fff;border:none;border-radius:10px;cursor:pointer;">2倍速</button>
  <button id="pause-btn" style="display:block;margin:12px auto 0 auto;padding:10px 28px;font-size:18px;background:#444;color:#fff;border:none;border-radius:10px;cursor:pointer;">暂停</button>
  <button id="start-btn" style="display:block;margin:24px auto 0 auto;padding:18px 40px;font-size:24px;background:#6cf;color:#222;border:none;border-radius:12px;cursor:pointer;">开始游戏</button>
  <canvas id="game" width="400" height="960"></canvas>
  <div id="upgrade-panel">
    <div id="upgrade-box">
      <h2>请选择升级</h2>
      <div id="upgrade-options"></div>
    </div>
  </div>
  <script>
    // 修复：获取canvas、ctx、info
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const info = document.getElementById('info');
    // ================== 基础设置 ==================
    const STAGE_WIDTH = 400;
    const STAGE_HEIGHT = 1200 * 0.8; // 画布和战场高度都为960
    const STAGE_PLAY_HEIGHT = 1200 * 0.8; // 实际战场高度
    const STAGE_TOP_OFFSET = STAGE_HEIGHT - STAGE_PLAY_HEIGHT; // 上方压缩高度
    const HERO_Y = STAGE_HEIGHT - 100;
    const HERO_MAX = 5;
    const HERO_MARGIN = 70;

    // 英雄配置
    const HERO_CONFIGS = [
      {
        name: "射手哥",
        type: "archer",
        range: 0.75,
        skill: "arrow",
        color: "#6cf"
      },
      {
        name: "激光哥",
        type: "laser",
        range: 1,
        skill: "laser",
        color: "#ffe066"
      },
      {
        name: "火焰哥",
        type: "fire",
        range: 0.5,
        skill: "fireball",
        color: "#ff6a00"
      },
      {
        name: "寒冰哥",
        type: "ice",
        range: 2/3,
        skill: "ice",
        color: "#00e0ff"
      },
      {
        name: "打雷哥",
        type: "lightning",
        range: 0.5,
        skill: "lightning",
        color: "#fff700"
      }
    ];

    // ================== 工具函数 ==================
    function shuffle(arr) {
      return arr.map(v => [Math.random(), v])
                .sort((a, b) => a[0] - b[0])
                .map(v => v[1]);
    }
    function getHeroPositions(count) {
      const totalWidth = (count - 1) * HERO_MARGIN;
      const startX = STAGE_WIDTH / 2 - totalWidth / 2;
      return Array.from({length: count}, (_, i) => startX + i * HERO_MARGIN);
    }
    function distance(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    // ================== 伤害数字 ==================
    let damageNumbers = [];
    function addDamageNumber(x, y, value, heroType, extra) {
      damageNumbers.push({x, y, value, heroType, alpha: 1, vy: -1, time: 0, extra: extra||''});
    }
    function drawDamageNumbers(ctx) {
      damageNumbers.forEach(dmg => {
        ctx.save();
        // 颜色映射
        let color = '#fff';
        let stroke = '#222';
        switch(dmg.heroType) {
          case 'archer': color = '#fff'; stroke = '#222'; break;
          case 'ice': color = '#00e0ff'; stroke = '#005577'; break;
          case 'fire': color = '#ff3b3b'; stroke = '#a80000'; break;
          case 'lightning': color = '#ffe066'; stroke = '#bba800'; break;
          case 'laser': color = '#b266ff'; stroke = '#4b0066'; break;
        }
        ctx.globalAlpha = dmg.alpha;
        if (dmg.small) {
          ctx.font = '14px Arial';
          ctx.fillStyle = color;
          ctx.textAlign = 'center';
          ctx.fillText(dmg.small, dmg.x, dmg.y+18);
        } else {
          ctx.font = 'bold 22px Arial';
          ctx.lineWidth = 3;
          ctx.strokeStyle = stroke;
          ctx.strokeText(dmg.value + (dmg.extra||''), dmg.x, dmg.y);
          ctx.fillStyle = color;
          ctx.fillText(dmg.value + (dmg.extra||''), dmg.x, dmg.y);
        }
        ctx.restore();
        dmg.y += dmg.vy;
        dmg.alpha -= 0.02;
        dmg.time += 1;
      });
      damageNumbers = damageNumbers.filter(dmg => dmg.alpha > 0);
    }

    // ================== 英雄类 ==================
    class Hero {
      constructor(config, x) {
        this.config = config;
        this.name = config.name;
        this.type = config.type;
        this.position = { x: x, y: HERO_Y };
        this.level = 1;
        this.cooldown = 0;
        this.lastAttack = 0;
        this.skillState = null;
        this.attackRange = {
          width: STAGE_WIDTH,
          height: STAGE_HEIGHT * config.range
        };
        // 攻击范围底部与英雄对齐
        this.rangeBottom = () => this.position.y;
        this.rangeTop = () => this.position.y - this.attackRange.height;
        this.rangeLeft = () => (STAGE_WIDTH - this.attackRange.width) / 2;
        this.rangeRight = () => (STAGE_WIDTH + this.attackRange.width) / 2;
        this.rangeCenter = { x: STAGE_WIDTH/2, y: STAGE_HEIGHT/2 };
        // 技能属性
        this.combo = 1;
        this.bulletCount = 1;
        this.bulletSplit = 0;
        // 伤害值
        this.damage = this.type === 'archer' ? 3 : (this.type === 'fire' ? 6 : (this.type === 'lightning' ? 5 : 0.5));
        // 激光哥tick和持续
        this.laserWidth = 8;
        this.laserDuration = 2000; // 激光哥持续2秒
        this.laserAlphaTick = 1;
        this.laserCombo = 1;
        this.laserDamage = this.type === 'laser' ? 0.5 : 0.3; // 激光哥每0.2秒0.5点
        this.laserDurationBonus = 0;
        this.laserWidthBonus = 0;
        this.fireExplosionRadius = 8 * 6;
        this.fireExplosionBonus = 0;
        this.fireCombo = 1;
        this.fireDamageBonus = 0;
        this.iceCombo = 1;
        this.iceDamageBonus = 0;
        this.iceFreeze = 0;
        this.lightningCombo = 1;
        this.lightningDamageBonus = 0;
        this.lightningStun = 0;
      }
      attack(enemies, bullets, effects) {
        const now = Date.now();
        if (now - this.lastAttack < this.getCooldown() / speedMultiplier) return;
        // 连击：每次攻击都包含当前的子弹+1效果
        const doAttack = () => {
          switch(this.config.skill) {
            case "arrow":
              this.arrowAttack(enemies, bullets, 0);
              break;
            case "laser":
              this.laserAttack(enemies, effects, 0);
              break;
            case "fireball":
              this.fireballAttack(enemies, bullets, effects, 0);
              break;
            case "ice":
              this.iceAttack(enemies, bullets, effects, 0);
              break;
            case "lightning":
              this.lightningAttack(enemies, effects, 0);
              break;
          }
        };
        doAttack();
        if (this.getCombo() > 1) {
          setTimeout(() => doAttack(), 250 / speedMultiplier);
        }
        this.lastAttack = Date.now();
      }
      getCooldown() {
        switch(this.config.skill) {
          case "arrow": return 1500; // 丛林射手1.5秒
          case "laser": return 6000; // 激光哥6秒
          case "fireball": return 3000; // 火焰法师3秒
          case "ice": return 2000;
          case "lightning": return 2500; // 闪电哥2.5秒
        }
        return 1000;
      }
      getCombo() {
        if (this.type === 'archer') return this.combo;
        if (this.type === 'fire') return this.fireCombo;
        if (this.type === 'laser') return this.laserCombo;
        if (this.type === 'ice') return this.iceCombo;
        if (this.type === 'lightning') return this.lightningCombo;
        return 1;
      }
      arrowAttack(enemies, bullets, comboIdx) {
        const target = this.findTarget(enemies);
        if (!target) return;
        const baseAngle = Math.atan2(target.position.y - this.position.y, target.position.x - this.position.x);
        const angleStep = 0.14; // 子弹间隔角度
        const n = this.bulletCount;
        if (n % 2 === 1) {
          // 奇数颗：中间那颗对齐敌人中心
          const center = (n - 1) / 2;
          for (let i = 0; i < n; i++) {
            const angle = baseAngle + (i - center) * angleStep;
            bullets.push(new Bullet(this.position, angle, 15, this.damage, "arrow", 1, this.type, this.bulletSplit));
          }
        } else {
          // 偶数颗：最靠近中间的左边那颗对齐敌人中心
          const leftCenter = n/2 - 1;
          for (let i = 0; i < n; i++) {
            const angle = baseAngle + (i - leftCenter) * angleStep;
            bullets.push(new Bullet(this.position, angle, 15, this.damage, "arrow", 1, this.type, this.bulletSplit));
          }
        }
      }
      laserAttack(enemies, effects, comboIdx) {
        const target = this.findTarget(enemies);
        if (!target) return;
        const from = {x: this.position.x, y: this.position.y};
        // 计算激光方向
        const dx = target.position.x - this.position.x;
        const dy = target.position.y - this.position.y;
        const angle = Math.atan2(dy, dx);
        // 计算终点：延长到屏幕边界
        let t = 10000; // 足够大
        let tx = from.x + Math.cos(angle) * t;
        let ty = from.y + Math.sin(angle) * t;
        // 找到与屏幕边界的交点
        // 横向边界
        if (Math.abs(Math.cos(angle)) > 1e-3) {
          let tx1 = (0 - from.x) / Math.cos(angle);
          let tx2 = (STAGE_WIDTH - from.x) / Math.cos(angle);
          let ty1 = from.y + tx1 * Math.sin(angle);
          let ty2 = from.y + tx2 * Math.sin(angle);
          if (tx1 > 0 && ty1 >= 0 && ty1 <= STAGE_HEIGHT) { tx = 0; ty = ty1; t = tx1; }
          if (tx2 > 0 && ty2 >= 0 && ty2 <= STAGE_HEIGHT && tx2 < t) { tx = STAGE_WIDTH; ty = ty2; t = tx2; }
        }
        // 纵向边界
        if (Math.abs(Math.sin(angle)) > 1e-3) {
          let ty1 = (0 - from.y) / Math.sin(angle);
          let ty2 = (STAGE_HEIGHT - from.y) / Math.sin(angle);
          let tx1 = from.x + ty1 * Math.cos(angle);
          let tx2 = from.x + ty2 * Math.cos(angle);
          if (ty1 > 0 && tx1 >= 0 && tx1 <= STAGE_WIDTH && ty1 < t) { tx = tx1; ty = 0; t = ty1; }
          if (ty2 > 0 && tx2 >= 0 && tx2 <= STAGE_WIDTH && ty2 < t) { tx = tx2; ty = STAGE_HEIGHT; t = ty2; }
        }
        const to = {x: tx, y: ty};
        const width = this.laserWidth * (1 + this.laserWidthBonus);
        const duration = this.laserDuration * (1 + this.laserDurationBonus);
        effects.push({
          type: "laser",
          from, to,
          start: Date.now(),
          duration,
          width,
          tick: 0,
          hero: this
        });
      }
      fireballAttack(enemies, bullets, effects, comboIdx) {
        const target = this.findTarget(enemies);
        if (!target) return;
        bullets.push(new Bullet(this.position, Math.atan2(target.position.y - this.position.y, target.position.x - this.position.x), 10, this.damage * (1 + this.fireDamageBonus), "fireball", 1, this.type, 0, this.fireExplosionRadius * (1 + this.fireExplosionBonus)));
      }
      iceAttack(enemies, bullets, effects, comboIdx) {
        const target = this.findTarget(enemies);
        if (!target) return;
        bullets.push(new Bullet(this.position, Math.atan2(target.position.y - this.position.y, target.position.x - this.position.x), 10, 3 * (1 + this.iceDamageBonus), "ice", 3, this.type, 0, 0, this.iceFreeze));
      }
      lightningAttack(enemies, effects, comboIdx) {
        const target = this.findTarget(enemies);
        if (!target) return;
        effects.push({
          type: "lightning",
          x: target.position.x,
          y: target.position.y,
          start: Date.now(),
          duration: 400,
          hero: this
        });
        effects.push({
          type: "lightning-flash",
          x: target.position.x,
          y: target.position.y,
          start: Date.now(),
          duration: 200
        });
        // 范围伤害
        const radius = target.radius * 2;
        let dmg = 5 * (1 + this.lightningDamageBonus);
        enemies.forEach(e2 => {
          if (e2.alive && e2.visible && Math.sqrt((e2.position.x - target.position.x) ** 2 + (e2.position.y - target.position.y) ** 2) <= radius) {
            addDamageNumber(e2.position.x, e2.position.y-30, Math.round(dmg), "lightning", "");
            e2.takeDamage(dmg, "lightning", "");
            if (this.lightningStun > 0) {
              e2.stunUntil = Math.max(e2.stunUntil || 0, Date.now() + 1000 * this.lightningStun);
            }
            e2.paralyzeUntil = Date.now() + 3000;
          }
        });
      }
      findTarget(enemies) {
        const left = this.rangeLeft();
        const right = this.rangeRight();
        const top = this.rangeTop();
        const bottom = this.rangeBottom();
        // 找到攻击范围内y值最大的敌人
        let candidates = enemies.filter(e =>
          e.visible &&
          e.position.x > left &&
          e.position.x < right &&
          e.position.y > top &&
          e.position.y < bottom
        );
        if (candidates.length === 0) return null;
        return candidates.reduce((maxE, e) => (e.position.y > maxE.position.y ? e : maxE), candidates[0]);
      }
    }

    // ================== 子弹类 ==================
    class Bullet {
      constructor(position, angle, speed, damage, type, pierce=1, heroType, split=0, explosionRadius=0, freeze=0, excludeTarget=null) {
        this.position = { x: position.x, y: position.y };
        this.velocity = { x: speed * Math.cos(angle), y: speed * Math.sin(angle) };
        this.damage = damage;
        this.radius = type === 'fireball' ? 10 : (type === 'ice' ? 9 : 8);
        this.type = type;
        this.active = true;
        this.pierce = pierce;
        this.hitEnemies = new Set();
        this.heroType = heroType;
        this.split = split;
        this.explosionRadius = explosionRadius;
        this.freeze = freeze;
        this.bulletSplitTimes = 0;
        this.excludeTarget = excludeTarget; // 新增：分裂子弹不能命中原目标
      }
      update() {
        this.position.x += this.velocity.x;
        this.position.y += this.velocity.y;
        if (this.position.x < 0 || this.position.x > STAGE_WIDTH ||
            this.position.y < 0 || this.position.y > STAGE_HEIGHT) {
          this.active = false;
        }
      }
    }

    // ================== 敌人类 ==================
    class Enemy {
      constructor(x, y, hp, scale=1, isBoss=false, appearTime=0) {
        this.position = { x, y };
        this.radius = 18 * scale;
        this.hp = hp;
        this.maxHp = hp;
        this.alive = true;
        this.speed = 0.25 + Math.random() * 0.5;
        this.slowUntil = 0;
        this.stunUntil = 0;
        this.frozenUntil = 0;
        this.isBoss = isBoss;
        this.appearTime = appearTime; // 新增：出现时间戳
        this.visible = false;
        this.burnUntil = 0; // 燃烧结束时间
        this.burnDps = 0;   // 燃烧伤害/秒
        this.lastBurnTick = 0;
        this.paralyzeUntil = 0; // 麻痹结束时间
      }
      update() {
        if (!this.visible) {
          if (Date.now() < this.appearTime) return;
          this.visible = true;
        }
        let speed = this.speed * speedMultiplier;
        if (Date.now() < this.slowUntil) speed *= 0.5;
        if (Date.now() < this.stunUntil) speed = 0;
        if (Date.now() < this.frozenUntil) speed = 0;
        this.position.y += speed;
        if (this.position.y > STAGE_HEIGHT) this.alive = false;
        // 燃烧伤害
        if (Date.now() < this.burnUntil) {
          if (!this.lastBurnTick) this.lastBurnTick = Date.now();
          while (this.lastBurnTick + 1000/speedMultiplier <= Date.now() && this.alive) {
            this.lastBurnTick += 1000/speedMultiplier;
            let dmg = Math.max(1, Math.round(this.burnDps));
            this.hp -= dmg;
            addDamageNumber(this.position.x, this.position.y-40, dmg, "fire", "");
          }
        } else {
          this.burnDps = 0;
          this.lastBurnTick = 0;
        }
      }
      // 处理麻痹加伤
      takeDamage(amount, heroType, extraText) {
        let dmg = amount;
        let isParalyze = Date.now() < this.paralyzeUntil;
        let baseDmg = Math.max(1, Math.round(amount));
        let paralyzeDmg = 0;
        if (isParalyze) {
          paralyzeDmg = Math.max(1, Math.round(baseDmg * 0.2));
          dmg = baseDmg + paralyzeDmg;
        } else {
          dmg = baseDmg;
        }
        this.hp -= dmg;
        // 主伤害数字
        addDamageNumber(this.position.x, this.position.y-30, baseDmg, heroType, extraText||'');
        // 麻痹加成单独跳字
        if (isParalyze && paralyzeDmg > 0) {
          addDamageNumber(this.position.x, this.position.y-50, '+'+paralyzeDmg, 'lightning', '');
          // 小字“麻痹”
          damageNumbers.push({x: this.position.x, y: this.position.y-38, value: '', heroType: 'lightning', alpha: 1, vy: 0, time: 0, extra: '', small: '麻痹'});
        }
      }
    }

    // ================== 玩家类 ==================
    class Player {
      constructor() {
        this.exp = 0;
        this.level = 1;
        this.heroes = [new Hero(HERO_CONFIGS[0], STAGE_WIDTH/2)];
        this.upgradeCounts = {};
        this.expThreshold = [5]; // 1级到2级5点
        this.killCount = 0;
        this.life = 10;
        this.updateExpThreshold(1);
      }
      updateExpThreshold() {
        // 每级+1
        this.expThreshold = [5 + (this.level-1)];
      }
      gainExp(amount) {
        this.exp += amount;
        while (this.exp >= this.expThreshold[0]) {
          this.exp -= this.expThreshold[0];
          this.level++;
          this.updateExpThreshold();
          showUpgrade(this);
        }
      }
      addHero(type) {
        if (this.heroes.find(h => h.type === type)) return;
        const idx = HERO_CONFIGS.findIndex(cfg => cfg.type === type);
        const positions = getHeroPositions(this.heroes.length + 1);
        this.heroes.push(new Hero(HERO_CONFIGS[idx], positions[this.heroes.length]));
        this.heroes.forEach((hero, i) => hero.position.x = positions[i]);
      }
    }

    // ================== 波次管理 ==================
    class WaveManager {
      constructor() {
        this.currentWave = 0;
        this.totalWaves = 20;
      }
      nextWave() {
        this.currentWave++;
      }
      spawnWave() {
        const enemies = [];
        const count = 5 + (this.currentWave - 1);
        let baseHp = 6 * (1 + 0.1 * (this.currentWave - 1));
        const segments = Math.min(count, 8);
        const now = Date.now();
        const interval = 15000; // 15秒
        for (let i = 0; i < count; i++) {
          const seg = i % segments;
          const segWidth = STAGE_WIDTH / segments;
          const x = segWidth * seg + segWidth/2 + (Math.random()-0.5)*segWidth*0.6;
          const yBase = 20 + seg * 30;
          const y = yBase + Math.random()*20 + STAGE_TOP_OFFSET;
          // 均匀分布在N秒内
          const appearTime = now + Math.floor(i * interval / count);
          enemies.push(new Enemy(x, y, baseHp, 1, false, appearTime));
        }
        // 特殊大怪分散x/y
        const bossWaves = [5, 10, 15, 20];
        if (bossWaves.includes(this.currentWave)) {
          const bossCount = 1;
          for (let i = 0; i < bossCount; i++) {
            let bossHp = 50, bossScale = 1.5;
            let y = 100 + i * 120 + Math.random()*60 + STAGE_TOP_OFFSET;
            let x = STAGE_WIDTH/(bossCount+1)*(i+1);
            if (this.currentWave === 10) { bossHp = 100; bossScale = 2; }
            if (this.currentWave === 15) { bossHp = 150; bossScale = 2.5; }
            if (this.currentWave === 20) { bossHp = 200; bossScale = 3; }
            enemies.push(new Enemy(x, y, bossHp, bossScale, true));
          }
        }
        return enemies;
      }
    }

    // ================== 升级选项生成 ==================
    function getUpgradeOptions(player) {
      const options = [];
      const counts = player.upgradeCounts;
      const has = type => player.heroes.find(h => h.type === type);
      if (!has('fire') && !counts['fire_spawn']) options.push({text: '火焰哥出场', key: 'fire_spawn'});
      if (has('fire') && (counts['fire_combo']||0)<2) options.push({text: '火焰哥连击+1', key: 'fire_combo'});
      if (has('fire') && (counts['fire_damage']||0)<10) options.push({text: '火焰哥伤害增加60%', key: 'fire_damage'});
      if (has('fire') && (counts['fire_explosion']||0)<2) options.push({text: '火焰哥爆炸范围扩大50%', key: 'fire_explosion'});
      if (!has('laser') && !counts['laser_spawn']) options.push({text: '激光哥出场', key: 'laser_spawn'});
      if (has('laser') && (counts['laser_damage']||0)<10) options.push({text: '激光哥伤害增加60%', key: 'laser_damage'});
      if (has('laser') && (counts['laser_duration']||0)<2) options.push({text: '激光哥持久输出', key: 'laser_duration'});
      if (has('laser') && (counts['laser_width']||0)<2) options.push({text: '激光哥光束变粗50%', key: 'laser_width'});
      if (!has('lightning') && !counts['lightning_spawn']) options.push({text: '打雷哥出场', key: 'lightning_spawn'});
      if (has('lightning') && (counts['lightning_damage']||0)<10) options.push({text: '打雷哥伤害增加60%', key: 'lightning_damage'});
      if (has('lightning') && (counts['lightning_combo']||0)<2) options.push({text: '打雷哥连击+1', key: 'lightning_combo'});
      if (has('lightning') && (counts['lightning_stun']||0)<2) options.push({text: '打雷哥附带晕眩', key: 'lightning_stun'});
      if (!has('ice') && !counts['ice_spawn']) options.push({text: '寒冰哥出场', key: 'ice_spawn'});
      if (has('ice') && (counts['ice_damage']||0)<10) options.push({text: '寒冰哥伤害增加60%', key: 'ice_damage'});
      if (has('ice') && (counts['ice_combo']||0)<2) options.push({text: '寒冰哥连击+1', key: 'ice_combo'});
      if (has('ice') && (counts['ice_freeze']||0)<2) options.push({text: '寒冰哥附带冻结', key: 'ice_freeze'});
      if ((counts['archer_combo']||0)<2) options.push({text: '射手哥连击+1', key: 'archer_combo'});
      if ((counts['archer_bullet']||0)<2) options.push({text: '射手哥子弹+1', key: 'archer_bullet'});
      if ((counts['archer_damage']||0)<10) options.push({text: '射手哥伤害增加60%', key: 'archer_damage'});
      if ((counts['archer_split']||0)<2) options.push({text: '射手哥子弹分裂+1', key: 'archer_split'});
      return shuffle(options).slice(0, 3);
    }

    // ================== 升级弹窗（点击式） ==================
    function showUpgrade(player) {
      const panel = document.getElementById('upgrade-panel');
      const optionsDiv = document.getElementById('upgrade-options');
      optionsDiv.innerHTML = '';
      const options = getUpgradeOptions(player);
      options.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'upgrade-btn';
        btn.innerText = opt.text;
        btn.onclick = () => {
          panel.style.display = 'none';
          player.upgradeCounts[opt.key] = (player.upgradeCounts[opt.key]||0)+1;
          // 处理升级效果
          if (opt.key === 'fire_spawn') player.addHero('fire');
          if (opt.key === 'fire_combo') player.heroes.find(h=>h.type==='fire').fireCombo++;
          if (opt.key === 'fire_damage') player.heroes.find(h=>h.type==='fire').fireDamageBonus += 0.6;
          if (opt.key === 'fire_explosion') player.heroes.find(h=>h.type==='fire').fireExplosionBonus += 0.5;
          if (opt.key === 'laser_spawn') player.addHero('laser');
          if (opt.key === 'laser_damage') player.heroes.find(h=>h.type==='laser').laserDamage += 0.6 * 0.3;
          if (opt.key === 'laser_duration') player.heroes.find(h=>h.type==='laser').laserDurationBonus += 0.5;
          if (opt.key === 'laser_width') player.heroes.find(h=>h.type==='laser').laserWidthBonus += 0.5;
          if (opt.key === 'lightning_spawn') player.addHero('lightning');
          if (opt.key === 'lightning_damage') player.heroes.find(h=>h.type==='lightning').lightningDamageBonus += 0.6;
          if (opt.key === 'lightning_combo') player.heroes.find(h=>h.type==='lightning').lightningCombo++;
          if (opt.key === 'lightning_stun') player.heroes.find(h=>h.type==='lightning').lightningStun++;
          if (opt.key === 'ice_spawn') player.addHero('ice');
          if (opt.key === 'ice_damage') player.heroes.find(h=>h.type==='ice').iceDamageBonus += 0.6;
          if (opt.key === 'ice_combo') player.heroes.find(h=>h.type==='ice').iceCombo++;
          if (opt.key === 'ice_freeze') player.heroes.find(h=>h.type==='ice').iceFreeze++;
          if (opt.key === 'archer_combo') player.heroes.find(h=>h.type==='archer').combo++;
          if (opt.key === 'archer_bullet') player.heroes.find(h=>h.type==='archer').bulletCount++;
          if (opt.key === 'archer_damage') player.heroes.find(h=>h.type==='archer').damage *= 1.6;
          if (opt.key === 'archer_split') player.heroes.find(h=>h.type==='archer').bulletSplit++;
        };
        optionsDiv.appendChild(btn);
      });
      panel.style.display = 'flex';
    }

    // ================== 攻击范围显示控制 ==================
    let selectedHeroIdx = null;
    // 修复：PC端click事件
    canvas.addEventListener('click', function(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let found = false;
      player.heroes.forEach((hero, idx) => {
        const dx = mx - hero.position.x * (canvas.width / canvas.offsetWidth);
        const dy = my - hero.position.y * (canvas.height / canvas.offsetHeight);
        if (dx*dx + dy*dy <= 22*22) {
          if (selectedHeroIdx === idx) {
            selectedHeroIdx = null;
          } else {
            selectedHeroIdx = idx;
          }
          found = true;
        }
      });
      if (!found) selectedHeroIdx = null;
    });
    // 移动端touch事件
    canvas.addEventListener('touchstart', function(e) {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const mx = touch.clientX - rect.left;
      const my = touch.clientY - rect.top;
      let found = false;
      player.heroes.forEach((hero, idx) => {
        const dx = mx - hero.position.x * (canvas.width / canvas.offsetWidth);
        const dy = my - hero.position.y * (canvas.height / canvas.offsetHeight);
        if (dx*dx + dy*dy <= 22*22) {
          if (selectedHeroIdx === idx) {
            selectedHeroIdx = null;
          } else {
            selectedHeroIdx = idx;
          }
          found = true;
        }
      });
      if (!found) selectedHeroIdx = null;
      e.preventDefault();
    }, {passive: false});

    // ================== 游戏主循环 ==================
    const player = new Player();
    const waveManager = new WaveManager();
    let enemies = waveManager.spawnWave();
    let bullets = [];
    let effects = [];
    let lastWaveTime = Date.now();
    let lastAutoWaveTime = Date.now();

    // 修复刷怪逻辑，避免多波同时生成
    let wavePending = false;
    let nextWaveTime = 0;
    let gameStarted = false;
    let gameStartTime = 0;
    // 开始游戏按钮逻辑，currentWave初始化为0，点击后设为1并生成第一波
    const startBtn = document.getElementById('start-btn');
    startBtn.onclick = function() {
      startBtn.style.display = 'none';
      gameStarted = true;
      waveManager.currentWave = 0;
      player.updateExpThreshold();
      player.killCount = 0;
      waveManager.nextWave();
      enemies = waveManager.spawnWave();
      wavePending = true;
      nextWaveTime = Date.now() + 10000;
      gameStartTime = Date.now();
    }
    // 2倍速控制
    let speedMultiplier = 1;
    const speedBtn = document.getElementById('speed-btn');
    speedBtn.onclick = function() {
      if (speedMultiplier === 1) {
        speedMultiplier = 2;
        speedBtn.style.background = '#6cf';
        speedBtn.style.color = '#222';
        speedBtn.innerText = '1倍速';
      } else {
        speedMultiplier = 1;
        speedBtn.style.background = '#444';
        speedBtn.style.color = '#fff';
        speedBtn.innerText = '2倍速';
      }
    }
    // 暂停功能
    let paused = false;
    const pauseBtn = document.getElementById('pause-btn');
    pauseBtn.onclick = function() {
      paused = !paused;
      if (paused) {
        pauseBtn.style.background = '#6cf';
        pauseBtn.style.color = '#222';
        pauseBtn.innerText = '继续';
      } else {
        pauseBtn.style.background = '#444';
        pauseBtn.style.color = '#fff';
        pauseBtn.innerText = '暂停';
        requestAnimationFrame(gameLoop);
      }
    }
    function gameLoop() {
      if (paused) {
        draw();
        return;
      }
      if (document.getElementById('upgrade-panel').style.display === 'flex') {
        requestAnimationFrame(gameLoop);
        return;
      }
      if (!gameStarted) {
        draw();
        requestAnimationFrame(gameLoop);
        return;
      }
      player.heroes.forEach(hero => {
        hero.attack(enemies, bullets, effects);
      });
      effects.forEach(eff => {
        if (eff.type === 'laser') {
          const hero = eff.hero;
          const now = Date.now();
          const t = now - eff.start;
          if (t > eff.duration) return;
          // tick每200ms
          if (!eff.lastTick || now - eff.lastTick >= 200) {
            enemies.forEach(enemy => {
              const a = eff.from, b = eff.to, p = enemy.position;
              const abx = b.x - a.x, aby = b.y - a.y;
              const apx = p.x - a.x, apy = p.y - a.y;
              const abLen = Math.sqrt(abx*abx + aby*aby);
              const proj = (apx*abx + apy*aby) / abLen;
              if (proj < 0 || proj > abLen) return;
              const closest = {x: a.x + abx * proj/abLen, y: a.y + aby * proj/abLen};
              const dist = distance(p, closest);
              if (enemy.visible && dist < eff.width/2 + enemy.radius) {
                let dmg = hero.laserDamage;
                enemy.takeDamage(dmg, "laser");
              }
            });
            eff.lastTick = now;
            eff.tick = (eff.tick||0)+1;
          }
        }
      });
      bullets.forEach(b => b.update());
      bullets = bullets.filter(b => b.active);
      enemies.forEach(e => e.update());
      // 检查敌人出界扣血
      enemies.forEach(enemy => {
        if (!enemy.alive && enemy.position.y > STAGE_HEIGHT) {
          if (enemy.isBoss) player.life -= 5;
          else player.life -= 1;
        }
      });
      enemies = enemies.filter(e => e.alive && e.hp > 0);

      bullets.forEach(bullet => {
        enemies.forEach((enemy, idx) => {
          if (enemy.alive && enemy.visible && bullet.active && !bullet.hitEnemies.has(enemy)) {
            // 分裂子弹不能命中原目标
            if (bullet.excludeTarget && bullet.excludeTarget === enemy) return;
            const dx = bullet.position.x - enemy.position.x;
            const dy = bullet.position.y - enemy.position.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < bullet.radius + enemy.radius) {
              bullet.hitEnemies.add(enemy);
              if (bullet.type === "fireball") {
                // 爆炸：以命中目标为圆心，爆炸半径为3x敌人半径
                const explosionRadius = enemy.radius * 3;
                effects.push({type: "explosion-area", x: enemy.position.x, y: enemy.position.y, r: explosionRadius, start: Date.now(), duration: 200});
                enemies.forEach(e2 => {
                  if (e2.alive && distance(e2.position, enemy.position) <= explosionRadius) {
                    e2.takeDamage(bullet.damage, "fire");
                    effects.push({type: "fire-flame", target: e2, start: Date.now(), duration: 350});
                    // 引燃效果
                    const fireHero = player.heroes.find(h=>h.type==='fire');
                    if (fireHero) {
                      e2.burnUntil = Date.now() + 3000;
                      e2.burnDps = Math.max(1, fireHero.damage * 10);
                    }
                  }
                });
                bullet.active = false;
              } else if (bullet.type === "ice") {
                enemy.takeDamage(bullet.damage, "ice");
                enemy.slowUntil = Date.now() + 2000;
                if (bullet.freeze) enemy.frozenUntil = Date.now() + 1000 * bullet.freeze;
                effects.push({type: "ice-effect", target: enemy, start: Date.now(), duration: 400});
                bullet.pierce--;
                if (bullet.pierce <= 0) bullet.active = false;
              } else if (bullet.type === "arrow") {
                enemy.takeDamage(bullet.damage, "archer");
                // 子弹碰撞部分，分裂子弹生成：
                if (bullet.split > 0 && bullet.bulletSplitTimes < 2) {
                  // 记录已选目标，确保每个分裂子弹目标不同
                  let usedTargets = new Set([enemy]);
                  for (let s = 0; s < bullet.split; s++) {
                    // 找到最近的未被选中的目标
                    let minDist = Infinity;
                    let nearest = null;
                    enemies.forEach(e2 => {
                      if (e2.alive && !usedTargets.has(e2)) {
                        const d = Math.sqrt((e2.position.x - enemy.position.x) ** 2 + (e2.position.y - enemy.position.y) ** 2);
                        if (d < minDist) {
                          minDist = d;
                          nearest = e2;
                        }
                      }
                    });
                    let angle;
                    if (nearest) {
                      angle = Math.atan2(nearest.position.y - enemy.position.y, nearest.position.x - enemy.position.x);
                      usedTargets.add(nearest);
                    } else {
                      angle = Math.random() * Math.PI * 2;
                    }
                    // 分裂次数达到2时，分裂子弹有0.5s间隔
                    if (bullet.bulletSplitTimes >= 1) {
                      setTimeout(() => {
                        bullets.push(new Bullet(
                          {x: enemy.position.x, y: enemy.position.y},
                          angle,
                          10,
                          bullet.damage * 0.5,
                          "arrow",
                          1,
                          bullet.heroType,
                          0,
                          0,
                          0,
                          enemy // excludeTarget: 原目标
                        ));
                      }, s * 500 / speedMultiplier);
                    } else {
                      bullets.push(new Bullet(
                        {x: enemy.position.x, y: enemy.position.y},
                        angle,
                        10,
                        bullet.damage * 0.5,
                        "arrow",
                        1,
                        bullet.heroType,
                        0,
                        0,
                        0,
                        enemy // excludeTarget: 原目标
                      ));
                    }
                  }
                }
                bullet.active = false;
              }
              if (enemy.hp <= 0) {
                enemy.alive = false;
                player.killCount++;
                // 经验获取
                if (enemy.isBoss) {
                  // 怪物直接升1级
                  player.exp = 0;
                  player.level++;
                  player.updateExpThreshold();
                  showUpgrade(player);
                } else {
                  player.gainExp(1);
                }
              }
            }
          }
        });
      });

      // 刷怪逻辑（每15秒一波）
      if (!wavePending && Date.now() >= nextWaveTime) {
        if (waveManager.currentWave < waveManager.totalWaves) {
          waveManager.nextWave();
          player.updateExpThreshold();
          player.killCount = 0;
          enemies = enemies.concat(waveManager.spawnWave());
          wavePending = true;
          nextWaveTime = Date.now() + 15000 / speedMultiplier;
        }
      }
      if (wavePending) {
        wavePending = false;
      }
      // 第一波特殊处理：2秒后生成
      if (waveManager.currentWave === 1 && enemies.length === 0 && Date.now() >= nextWaveTime) {
        enemies = waveManager.spawnWave();
        wavePending = true;
        // 下一波时间为10~15秒后
        nextWaveTime = Date.now() + (10000 + Math.random() * 5000);
      }

      draw();
      effects = effects.filter(eff => Date.now() - eff.start < eff.duration);
      requestAnimationFrame(gameLoop);
    }

    function drawFlame(ctx, x, y, scale=1) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-8, -16, -12, -36, 0, -48);
      ctx.bezierCurveTo(12, -36, 8, -16, 0, 0);
      ctx.closePath();
      const grad = ctx.createLinearGradient(0, 0, 0, -48);
      grad.addColorStop(0, "orange");
      grad.addColorStop(0.5, "#ff0");
      grad.addColorStop(1, "#fff");
      ctx.fillStyle = grad;
      ctx.shadowColor = "#ff0";
      ctx.shadowBlur = 18;
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-6, -10);
      ctx.bezierCurveTo(-10, -18, -8, -28, -2, -32);
      ctx.bezierCurveTo(-2, -28, -4, -18, -6, -10);
      ctx.closePath();
      ctx.fillStyle = "#ffb300";
      ctx.shadowBlur = 0;
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(6, -10);
      ctx.bezierCurveTo(10, -18, 8, -28, 2, -32);
      ctx.bezierCurveTo(2, -28, 4, -18, 6, -10);
      ctx.closePath();
      ctx.fillStyle = "#ffd700";
      ctx.fill();
      ctx.restore();
    }
    function drawIceEffect(ctx, x, y, scale=1) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      ctx.beginPath();
      ctx.arc(0, 0, 26, 0, Math.PI*2);
      ctx.strokeStyle = "#aef6ff";
      ctx.lineWidth = 4;
      ctx.setLineDash([6, 4]);
      ctx.globalAlpha = 0.7;
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = "#e0f7fa";
      ctx.lineWidth = 2;
      for(let i=0;i<6;i++){
        ctx.save();
        ctx.rotate(Math.PI/3*i);
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0,-18);
        ctx.stroke();
        ctx.restore();
      }
      ctx.restore();
    }

    // ================== 渲染函数 ==================
    function drawHeroIcon(ctx, hero) {
      ctx.save();
      ctx.translate(hero.position.x, hero.position.y);
      switch(hero.type) {
        case 'archer':
          // 射手哥：弓和箭
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(0, 0, 18, Math.PI*0.7, Math.PI*1.3, false);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(-8, -10); ctx.lineTo(12, 0); ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(12, 0); ctx.lineTo(8, -4); ctx.moveTo(12, 0); ctx.lineTo(8, 4); ctx.stroke();
          break;
        case 'laser':
          // 激光哥：头盔+护目镜
          ctx.fillStyle = '#ffe066';
          ctx.beginPath();
          ctx.ellipse(0, 0, 16, 18, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#222';
          ctx.fillRect(-10, -4, 20, 8);
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.strokeRect(-10, -4, 20, 8);
          break;
        case 'fire':
          // 火焰哥：火焰头
          drawFlame(ctx, 0, 0, 0.7);
          break;
        case 'ice':
          // 寒冰哥：雪花头
          ctx.strokeStyle = '#00e0ff';
          ctx.lineWidth = 3;
          for(let i=0;i<6;i++){
            ctx.save();
            ctx.rotate(Math.PI/3*i);
            ctx.beginPath();
            ctx.moveTo(0,0); ctx.lineTo(0,-16); ctx.stroke();
            ctx.restore();
          }
          ctx.beginPath();
          ctx.arc(0,0,7,0,Math.PI*2);
          ctx.stroke();
          break;
        case 'lightning':
          // 打雷哥：闪电头
          ctx.strokeStyle = '#fff700';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(-8,-12); ctx.lineTo(0,0); ctx.lineTo(-4,0); ctx.lineTo(8,12); ctx.stroke();
          break;
      }
      ctx.restore();
    }
    function drawBullet(ctx, bullet) {
      ctx.save();
      if (bullet.type === 'arrow') {
        ctx.translate(bullet.position.x, bullet.position.y);
        ctx.rotate(Math.atan2(bullet.velocity.y, bullet.velocity.x));
        ctx.fillStyle = '#fff';
        ctx.fillRect(-10, -2, 16, 4);
        ctx.beginPath();
        ctx.moveTo(6, -4); ctx.lineTo(12, 0); ctx.lineTo(6, 4); ctx.closePath();
        ctx.fillStyle = '#6cf';
        ctx.fill();
      } else if (bullet.type === 'fireball') {
        drawFlame(ctx, bullet.position.x, bullet.position.y, 0.4 + 0.1*Math.sin(Date.now()/80));
      } else if (bullet.type === 'ice') {
        ctx.translate(bullet.position.x, bullet.position.y);
        ctx.strokeStyle = '#00e0ff';
        ctx.lineWidth = 2;
        for(let i=0;i<6;i++){
          ctx.save();
          ctx.rotate(Math.PI/3*i);
          ctx.beginPath();
          ctx.moveTo(0,0); ctx.lineTo(0,-8); ctx.stroke();
          ctx.restore();
        }
        ctx.beginPath();
        ctx.arc(0,0,3,0,Math.PI*2);
        ctx.stroke();
      } else if (bullet.type === 'laser') {
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = '#ffe066';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(bullet.position.x-20, bullet.position.y);
        ctx.lineTo(bullet.position.x+20, bullet.position.y);
        ctx.stroke();
      } else if (bullet.type === 'lightning') {
        ctx.strokeStyle = '#fff700';
        ctx.lineWidth = 4;
        ctx.beginPath();
        let x = bullet.position.x, y = bullet.position.y;
        for(let i=0;i<6;i++){
          ctx.lineTo(x+Math.random()*12-6, y+8+i*8);
          x = x+Math.random()*12-6;
          y = y+8;
        }
        ctx.stroke();
      }
      ctx.restore();
    }
    function draw() {
      ctx.clearRect(0, 0, STAGE_WIDTH, STAGE_HEIGHT);
      player.heroes.forEach((hero, idx) => {
        drawHeroIcon(ctx, hero);
        ctx.save();
        ctx.font = '16px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(hero.name, hero.position.x, hero.position.y + 28);
        ctx.restore();
        // 攻击范围（仅选中英雄显示，且为虚线，底部与英雄对齐）
        if (selectedHeroIdx === idx) {
          ctx.save();
          ctx.setLineDash([8, 8]);
          ctx.strokeStyle = 'rgba(255,255,0,0.7)';
          ctx.lineWidth = 2;
          ctx.strokeRect(
            hero.rangeLeft(),
            hero.rangeTop(),
            hero.attackRange.width,
            hero.attackRange.height
          );
          ctx.setLineDash([]);
          ctx.restore();
        }
      });
      bullets.forEach(bullet => {
        drawBullet(ctx, bullet);
      });
      enemies.forEach(enemy => {
        if (!enemy.visible && Date.now() < enemy.appearTime) return;
        ctx.save();
        // 状态色优先
        let mainColor = enemy.isBoss ? '#ff9800' : '#3f3';
        let grad = ctx.createRadialGradient(enemy.position.x, enemy.position.y, enemy.radius*0.3, enemy.position.x, enemy.position.y, enemy.radius);
        if (enemy.isBoss) {
          grad.addColorStop(0, '#fff3b0');
          grad.addColorStop(0.5, '#ffb347');
          grad.addColorStop(1, '#ff9800');
        } else {
          grad.addColorStop(0, '#fff');
          grad.addColorStop(0.5, '#7fff7f');
          grad.addColorStop(1, '#3f3');
        }
        // 状态色覆盖
        if (Date.now() < enemy.frozenUntil) grad = null, mainColor = '#b3e6ff';
        else if (Date.now() < enemy.slowUntil) grad = null, mainColor = '#0ff';
        else if (Date.now() < enemy.stunUntil) grad = null, mainColor = '#fff700';
        // 主体
        ctx.beginPath();
        ctx.arc(enemy.position.x, enemy.position.y, enemy.radius, 0, Math.PI*2);
        ctx.closePath();
        ctx.fillStyle = grad ? grad : mainColor;
        ctx.shadowColor = grad ? (enemy.isBoss ? '#ff9800' : '#7fff7f') : mainColor;
        ctx.shadowBlur = enemy.isBoss ? 18 : 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        // boss怒眉
        if (enemy.isBoss && !grad) {
          ctx.save();
          ctx.strokeStyle = '#a85600';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(enemy.position.x-enemy.radius*0.5, enemy.position.y-enemy.radius*0.5);
          ctx.lineTo(enemy.position.x-enemy.radius*0.1, enemy.position.y-enemy.radius*0.2);
          ctx.moveTo(enemy.position.x+enemy.radius*0.5, enemy.position.y-enemy.radius*0.5);
          ctx.lineTo(enemy.position.x+enemy.radius*0.1, enemy.position.y-enemy.radius*0.2);
          ctx.stroke();
          ctx.restore();
        }
        // 眼睛
        ctx.save();
        ctx.fillStyle = '#222';
        let eyeY = enemy.position.y - enemy.radius*0.2;
        let eyeDX = enemy.radius*0.32;
        ctx.beginPath();
        ctx.ellipse(enemy.position.x-eyeDX, eyeY, enemy.radius*0.16, enemy.radius*0.22, 0, 0, Math.PI*2);
        ctx.ellipse(enemy.position.x+eyeDX, eyeY, enemy.radius*0.16, enemy.radius*0.22, 0, 0, Math.PI*2);
        ctx.fill();
        // boss怒眉
        if (enemy.isBoss && grad) {
          ctx.save();
          ctx.strokeStyle = '#a85600';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(enemy.position.x-eyeDX, eyeY-enemy.radius*0.18);
          ctx.lineTo(enemy.position.x-eyeDX*0.3, eyeY-enemy.radius*0.05);
          ctx.moveTo(enemy.position.x+eyeDX, eyeY-enemy.radius*0.18);
          ctx.lineTo(enemy.position.x+eyeDX*0.3, eyeY-enemy.radius*0.05);
          ctx.stroke();
          ctx.restore();
        }
        ctx.restore();
        // 嘴巴
        ctx.save();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = enemy.isBoss ? 4 : 2;
        ctx.beginPath();
        if (enemy.isBoss) {
          ctx.arc(enemy.position.x, enemy.position.y+enemy.radius*0.25, enemy.radius*0.32, Math.PI*0.1, Math.PI*0.9, false);
        } else {
          ctx.arc(enemy.position.x, enemy.position.y+enemy.radius*0.28, enemy.radius*0.18, Math.PI*0.15, Math.PI*0.85, false);
        }
        ctx.stroke();
        ctx.restore();
        ctx.fillStyle = '#f44';
        ctx.fillRect(enemy.position.x - 15, enemy.position.y - 28, 30 * (enemy.hp/enemy.maxHp), 4);
        ctx.restore();
      });
      effects.forEach(eff => {
        if (eff.type === "laser") {
          const hero = eff.hero;
          const now = Date.now();
          let alpha = 0.3;
          if (eff.lastTick && now - eff.lastTick < 80) alpha = 1;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = "#ffe066";
          ctx.lineWidth = eff.width;
          ctx.beginPath();
          ctx.moveTo(eff.from.x, eff.from.y);
          ctx.lineTo(eff.to.x, eff.to.y);
          ctx.stroke();
          ctx.restore();
        } else if (eff.type === "explosion-area") {
          ctx.save();
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.r, 0, Math.PI*2);
          ctx.fillStyle = "rgba(255,120,0,0.18)";
          ctx.fill();
          ctx.restore();
        } else if (eff.type === "fire-flame") {
          if (eff.target && eff.target.alive) {
            drawFlame(ctx, eff.target.position.x, eff.target.position.y, 1.5);
          }
        } else if (eff.type === "ice-effect") {
          if (eff.target && eff.target.alive) {
            drawIceEffect(ctx, eff.target.position.x, eff.target.position.y, 1);
          }
        } else if (eff.type === "lightning") {
          ctx.save();
          ctx.strokeStyle = "#fff700";
          ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.moveTo(eff.x, eff.y-80);
          ctx.lineTo(eff.x, eff.y+20);
          ctx.stroke();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(eff.x, eff.y-40);
          ctx.lineTo(eff.x-15, eff.y-10);
          ctx.moveTo(eff.x, eff.y-20);
          ctx.lineTo(eff.x+20, eff.y+10);
          ctx.stroke();
          ctx.restore();
        } else if (eff.type === "lightning-flash") {
          ctx.save();
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, 40, 0, Math.PI*2);
          ctx.fillStyle = "#fff";
          ctx.fill();
          ctx.restore();
        }
      });
      drawDamageNumbers(ctx);
      // 先画等级、经验、生命值，再画经验条，避免被遮挡
      // 经验条
      const barX = 20, barY = STAGE_HEIGHT-48, barW = STAGE_WIDTH-40, barH = 18;
      ctx.save();
      // 背景
      ctx.fillStyle = '#222';
      ctx.strokeStyle = '#6cf';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(barX, barY, barW, barH, 8);
      ctx.fill();
      ctx.stroke();
      // 进度
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(barX, barY, barW * (player.exp/(player.expThreshold[0]||1)), barH, 8);
      ctx.clip();
      const grad = ctx.createLinearGradient(barX, barY, barX+barW, barY);
      grad.addColorStop(0, '#6cf');
      grad.addColorStop(1, '#3cf');
      ctx.fillStyle = grad;
      ctx.fillRect(barX, barY, barW, barH);
      ctx.restore();
      // 文字
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // 文字描边增强可读性
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0,0,0,0.5)';
      ctx.strokeText(`Lv.${player.level}  EXP: ${player.exp}/${player.expThreshold[0]||'-'}`, barX+barW/2, barY+barH/2);
      ctx.fillStyle = '#fff';
      ctx.fillText(`Lv.${player.level}  EXP: ${player.exp}/${player.expThreshold[0]||'-'}`, barX+barW/2, barY+barH/2);
      ctx.restore();
      // 游戏时间和生命值
      if (gameStarted) {
        ctx.save();
        ctx.font = '18px Arial';
        ctx.fillStyle = '#fff';
        const sec = Math.floor((Date.now() - gameStartTime) * speedMultiplier / 1000);
        const min = Math.floor(sec/60);
        const s = sec%60;
        ctx.textAlign = 'left';
        ctx.fillText(`时间: ${min}:${s.toString().padStart(2,'0')}`, 20, 32);
        ctx.font = '18px Arial';
        ctx.fillStyle = '#ff5a5a';
        ctx.textAlign = 'left';
        ctx.fillText(`生命值: ${player.life}`, 140, 32);
        ctx.restore();
      }
      info.innerHTML = `波次：${waveManager.currentWave}/${waveManager.totalWaves} &nbsp; 剩余敌人：${enemies.filter(e=>e.visible).length}`;
    }

    gameLoop();
  </script>
</body>
</html>